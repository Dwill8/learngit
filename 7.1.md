# 7.1 学习日志
##effective java 3 之：
# 限制源文件只有一个顶级类

&emsp;&emsp;虽然 Java 编译器允许您在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。风险源于这样的事实：在源文件中定义多个顶级类可以为类提供多种定义。使用哪种定义受源文件传递给编译器的顺序的影响。

&emsp;&emsp;为了使这个事实更加具体点，请参考下面这个源文件，它只包含一个 Main 类，它引用另外两个顶级类（Utensil 和 Dessert）的成员：

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(Utensil.NAME + Dessert.NAME);
    }
}
```

&emsp;&emsp;现在假设您在名为 Utensil.java 的单个源文件中定义了 Utensil 和 Dessert：

```java
// Two classes defined in one file. Don't ever do this!
class Utensil {
    static final String NAME = "pan";
}
class Dessert {
    static final String NAME = "cake";
}
```

&emsp;&emsp;main 程序当然会打印出`pancake`。

&emsp;&emsp;现在假设你不小心创建了另一个名为 Dessert.java 的源文件，该文件定义了相同的两个类：

```java
// Two classes defined in one file. Don't ever do this!
class Utensil {
    static final String NAME = "pot";
}
class Dessert {
    static final String NAME = "pie";
}
```

&emsp;&emsp;如果你有幸使用命令`javac Main.java Dessert.java`编译程序，编译将失败，编译器会告诉你，你已经多次定义了 Utensil 和 Dessert 类。这是因为编译器将首先编译 Main.java，当它看到对 Utensil 的引用（在引用 Dessert 之前）时，它将在 Utensil.java 中查找此类，并且找到了 Utensil 和 Dessert。当编译器在命令行遇到 Dessert.java 时，它也会拉入该文件，导致它遇到 Utensil 和 Dessert 的两个定义。

&emsp;&emsp;如果使用命令`javac Main.java`或`javac Main.java Utensil.java`编译程序，它将像编写 Dessert.java 文件之前一样运行，打印 pancake。 但是如果使用命令`javac Dessert.java Main.java`编译程序，它将打印 potpie。 因此，程序的行为受源文件传递给编译器的顺序的影响，这显然是不可接受的。

&emsp;&emsp;解决这个问题非常简单，只需要将顶级类（在我们的示例中为 Utensil 和 Dessert）拆分为单独的源文件。如果你想将多个顶级类放入单个源文件中，请考虑使用静态成员类（第 24 项）作为将类拆分为单独源文件的替代方法。如果这些类是属于另一个类的，那么将它们变成静态成员类通常是更好的选择，因为它增强了可读性，并且可以通过将它们声明为私有的来减少类的可访问性（第 15 项）。以下是我们的示例在静态成员类时的情况：

```java
// Static member classes instead of multiple top-level classes
public class Test {
    public static void main(String[] args) {
        System.out.println(Utensil.NAME + Dessert.NAME);
    }
    private static class Utensil {
        static final String NAME = "pan";
    }
    private static class Dessert {
        static final String NAME = "cake";
    }
}
```

&emsp;&emsp;教训很明确：永远不要将多个顶级类或接口放在单个源文件中。遵循这个规则就能够确保在编译的时候不会出现一个类有多个定义。这反过来保证了编译生成的类文件以及生成程序的行为与源文件传递给编译器的顺序无关。

# 不要使用原始类型

&emsp;&emsp;先来介绍一些术语。声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口[JLS, 8.1.2, 9.1.2]。例如，List 接口就只有单个类型参数 E，表示列表的元素类型。接口的全名是 List\<E\>（读作“E 的列表”），但人们通常简称为 List。泛型类和接口统称为泛型类型（generic type）。

&emsp;&emsp;每种泛型定义一组参数化的类型（parameterized type），构成格式为：先是类或者接口的名称，接着用尖括号把对应于泛型形式类型参数的实际类型参数列表\[JLS,4.4,4.5\]括起来。例如，List\<String\>（读作“字符串列表”）是一个参数化的类型，表示元素类型为 String 的列表。（String 是与形式类型参数 E 相对应的实际类型参数。）

&emsp;&emsp;最后，每个泛型都定义一个原始类型（raw type），即不带任何实际类型参数的泛型名称\[JLS,4.8\]。例如，与 List\<E\>对应的原始类型是 List。原始类型就像从类型声明中删除了所有泛型信息一样。它们的存在主要是为了与之前的泛型代码兼容。

&emsp;&emsp;在将泛型添加到 Java 之前，这是一个规范的集合声明。从 Java 9 开始，它仍然是合法的，但并不是很规范：

```java
// Raw collection type - don't do this!
// My stamp collection. Contains only Stamp instances.
private final Collection stamps = ... ;
```

&emsp;&emsp;如果你今天使用这个声明然后不小心将 coin 放入你的 stamp 集合中，这一错误的插入照样会编译并运行并且不会出现任何错误提示（尽管编译器发出了模糊的警告）：

```java
// Erroneous insertion of coin into stamp collection
stamps.add(new Coin( ... )); // Emits "unchecked call" warning
```

&emsp;&emsp;直到从 stamp 集合中获取 coin 时才会收到错误提示：

```java
// Raw iterator type - don't do this!
for (Iterator i = stamps.iterator(); i.hasNext(); )
    Stamp stamp = (Stamp) i.next(); // Throws ClassCastException
stamp.cancel();
```

&emsp;&emsp;就如本书中经常提到的，出错之后应该尽快发现，最好是编译时就发现。本例中，知道运行时才发现错误，已经出错很久了，而且你在代码中所处的文字距离包含错误的这部分代码已经很远了。一旦发现 ClassCastException，就必须搜索代码，查找将 coin 放进 stamp 集合的方法调用。此时编译器帮不上忙，因为它无法理解这种注释：“Contains only Stamp instances（只包含 stamp 实例）”。

&emsp;&emsp;有了泛型，就可以利用改进后的类型声明来代替集合中的这种注释，告诉编译器之前的注释中所隐含的信息：

```java
// Parameterized collection type - typesafe
private final Collection<Stamp> stamps = ... ;
```

&emsp;&emsp;通过这条声明，编译器知道 stamps 应该只包含 Stamp 实例，并给予保证，假设将你的整个代码进行编译，所有代码在编译过程中都没有发出（或者禁止，见第 27 项）任何警告。当 stamps 利用一个参数化的类型进行声明时，错误的插入会产生一条编译时的错误消息，准确地告诉你哪里出错了：

```java
Test.java:9: error: incompatible types: Coin cannot be converted to Stamp
c.add(new Coin());
        ^
```

&emsp;&emsp;当从集合中检索元素时，编译器会为您插入不可见的强制转换，并保证它们不会失败（再次假设您的所有代码都没有生成或禁止任何编译器警告）。虽然意外地将 coin 插入 stamp 集合的假设可能看起来很牵强，但问题仍然存在。例如，很容易想象将 BigInteger 放入一个应该只包含 BigDecimal 实例的集合中。

&emsp;&emsp;如上所述，如果不提供类型参数，使用集合类型和其他泛型也仍然是合法的，但是不应该这么做。**如果使用原始类型，就是失去了泛型在安全性和表述性方面的所有优势**。既然不应该使用原始类型，为什么 Java 的设计者还允许使用它们呢？这是为了提供兼容性。因为泛型出现的时候，Java 平台即将进入它的第二个十年，已经存在大量没有使用泛型的 Java 代码。人们认为让所有这些代码保持合法，并且能够与使用泛型的新代码互用，这一点很重要。它必须合法，才能将参数化类型的实例传递给那些被设计成使用普通类型的方法，反之亦然。这种需求被称作移植兼容性（Migration Compatibility），促成了支持原始类型的决定并使用擦除（erasure）来实现泛型（第 28 项）。

&emsp;&emsp;虽然不应该在新代码中使用像 List 这样的原生态类型，使用参数化的类型以允许插入任意对象，如 List\<Object\>，这还是可以的。原始类型 List 和参数化的类型 List\<Object\>之间到底有什么区别呢？不严格地说，前者逃避了泛型检查，后者则明确告知编译器，它能够持有任意类型的对象。虽然你可以将 List\<String\>传递给类型 List 参数，但是不能将它传给类型 List\<Object\>的参数。泛型有子类化（subtyping）的规则，List\<String\>是原始类型 List 的一个子类型，而不是参数化类型 List\<Object\>的子类型（第 28 项）。因此，**如果使用像 List 这样的原始类型，就会失去类型安全性，但是如果使用像 List\<Object\>这样的参数化类型，则不会**。

&emsp;&emsp;为了更具体地进行说明，请参考下面的程序：

```java
// Fails at runtime - unsafeAdd method uses a raw type (List)!
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    unsafeAdd(strings, Integer.valueOf(42));
    String s = strings.get(0); // Has compiler-generated cast
}
private static void unsafeAdd(List list, Object o) {
    list.add(o);
}
```

&emsp;&emsp;这个程序可以进行编译，但是因为它使用了原始类型 List，你会收到一条警告：

```java
Test.java:10: warning: [unchecked] unchecked call to add(E) as a member of the raw type List
    list.add(o);
        ^
```

&emsp;&emsp;实际上，如果运行这段程序，在程序试图将 strings.get(0)的调用结果转换成一个 String 时，会收到一个 ClassCastException 异常。这是一个编译器生成的转换，因此一般会保证成功，但是我们在这个例子中忽略了一条编译器的警告，就会为此而付出代价。

&emsp;&emsp;如果在 unsafeAdd 声明中用参数化类型 List\<Object\>代替原始类型 List，并试着重新编译这段程序，会发现它无法再进行编译了。以下是它的错误消息：

```java
Test.java:5: error: incompatible types: List<String> cannot be converted to List<Object>
unsafeAdd(strings, Integer.valueOf(42));
    ^
```

&emsp;&emsp;在不确定或者不在乎集合中的元素类型的情况下，你也许会使用原始类型。例如，假设想要编写一个方法，它有两个集合（set），并从中返回它们公有的元素的数量。如果你对泛型还不熟悉的话，可以参考以下方式来编写这种方法：

```java
// Use of raw type for unknown element type - don't do this!
static int numElementsInCommon(Set s1, Set s2) {
    int result = 0;
    for (Object o1 : s1)
        if (s2.contains(o1))
            result++;
    return result;
}
```

&emsp;&emsp;这个方法倒是可以工作，但它使用了原始类型，这是很危险的。安全的替代方法是使用无限制的通配符类型（unbounded wildcard type）。如果要使用泛型，但不确定或者不关心实际的类型参数，就可以使用一个问号代替。例如，泛型 Set\<E\>的无限制通配符类型为 Set\<?\>（读作“某个类型的集合”）。这是最普通的参数化 Set 类型，可以持有任何集合。下面是 numElementsInCommon 方法使用了无限制通配符类型时的情形：

```java
// Uses unbounded wildcard type - typesafe and flexible
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }
```

&emsp;&emsp;在无限制通配类型 Set\<?\>和原生态类型 Set 之间有什么区别呢？这个问号真正起到了作用吗？这一点不需要赘述，但是通配符类型是安全的，原始类型则是不安全的。由于可以将任何元素放进使用原始类型的集合中，因此很容易破坏该集合的类型约束条件（如 119 页【原书】的例子中所述的 unsafeAdd 方法）；但不能将任何元素（除 null 之外）放到 Collection\<?\>中。如果尝试这么做的话，将会产生一条像这样的编译时错误消息：

```java
WildCard.java:13: error: incompatible types: String cannot be converted to CAP#1
    c.add("verboten");
        ^
where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ?
```

&emsp;&emsp;无可否认，这个错误消息留下了以下期望的东西，但是编译器已经尽到了它的职责，防止你破坏集合的类型约束条件。你不仅无法将任何元素（除了 null 之外）放进 Collection\<?\>中，而且根本无法猜测你会得到哪种类型的对象。要是无法接受这些限制，就可以使用泛型方法（generic method，第 30 项）或者有限制的通配符类型（bounded wildcard type，第 31 项）。

&emsp;&emsp;不要在代码中使用原始类型，这条规则有一些小小的例外。**在类文字（class literal）中必须使用原生态类型。** 规范不允许使用参数化类型（虽然允许数组类型和基本类型）\[JLS, 15.8.2\]。换句话说，`List.class，String[].class` 和 `int.class` 都合法，但是 List\<String.class\>和 List\<?\>.class 则不合法。

&emsp;&emsp;这条规则的第二个例外与 instanceof 操作符有关。由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用 instanceof 操作符是非法的。用无限制通配符类型代替原始类型，对 instanceof 操作符的行为不会产生任何影响。在这种情况下，尖括号（<>）和问号（?）就显得多余了。**下面是利用泛型类使用 instanceof 操作符的首选方法**：

```java
// Legitimate use of raw type - instanceof operator
if (o instanceof Set) { // Raw type
    Set<?> s = (Set<?>) o; // Wildcard type
    ...
}
```

&emsp;&emsp;注意，一旦确定这个 o 是个 Set，就必须将它转换成通配符类型 Set\<?\>，而不是转换成原生类型 Set。这是个受检的（checked）转换，因此不会导致编译时警告。

&emsp;&emsp;总之，使用原始类型会在运行时导致异常，因此不要在代码中使用它们。原始类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。让我们做个快速的回顾：Set\<Object\>是个参数化类型，表示可以包含任何对象类型的一个集合；Set\<?\>则是一个通配符类型，表示只能包含某种位置对象类型的一个集合；Set 则是个原始类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。

&emsp;&emsp;为了便于快速参考，本项中介绍的术语（以及本章后面介绍的一些术语）总结在下表中：

| 术语             | 示例                                   | 所在项       |
| ---------------- | -------------------------------------- | ------------ |
| 参数化的类型     | List\<String\>                         | 第 26 项     |
| 实际类型参数     | String                                 | 第 26 项     |
| 泛型             | List\<E\>                              | 第 26、29 项 |
| 形式类型参数     | E                                      | 第 26 项     |
| 无限制通配符类型 | List\<?\>                              | 第 26 项     |
| 原生态类型       | List                                   | 第 26 项     |
| 有限制类型参数   | \<E extends Number\>                   | 第 29 项     |
| 递归类型限制     | \<T extends Comparable\<T\>\>          | 第 30 项     |
| 有限制通配符类型 | List\<? extends Number\>               | 第 31 项     |
| 泛型方法         | static \<E\> List\<E\> asList(E\[\] a) | 第 30 项     |
| 类型令牌         | String.class                           | 第 33 项     |



# 列表优先于数组

&emsp;&emsp;数组与泛型相比，有两个重要的不同点。首先，数组是协变的（covariant）。这个词听起来有点吓人，其实只是表示如果 Sub 为 Super 的子类型，那么数组类型 Sub\[\]就是 Super\[\]的子类型。相反，泛型则是不可变的（invariant）：对于任意两个不同的类型 Type1 和 Type2，List\<Type1\>既不是 List\<Type2\>的子类型，也不是 List\<Type2\>的超类型[JLS, 4.10; Naftalin07, 2.5]。你可能认为，这意味着泛型是有缺陷的，但实际上可以说数组才是有缺陷的。下面的代码片段是合法的：

```java
// Fails at runtime!
Object[] objectArray = new Long[1];
objectArray[0] = "I don't fit in"; // Throws ArrayStoreException
```

&emsp;&emsp;但下面这段代码是不合法的：

```java
// Won't compile!
List<Object> ol = new ArrayList<Long>(); // Incompatible types
ol.add("I don't fit in");
```

&emsp;&emsp;这其中无论那种方法，都不能将 String 放进 Long 容器中，但是利用数组，你会在运行时发现所犯的错误，利用列表，则可以在编译时发现错误。我们当然希望在编译时发现错误了。

&emsp;&emsp;数组与泛型之间的第二大区别在于，数组是*具体化的（reified）*[JLS, 4.7]。因此数组会在运行时才知道并检查它们的元素类型约束。如上所述，如果你企图将 String 保存到 Long 数组中，就会的得到一个`ArrayStoreException`异常。相比之下，泛型则是通过*擦除（erasure）* [JLS, 4.6]来实现的。因此泛型只是在编译时强化它们的类型信息，并在运行时丢弃（或者*擦除* ）它们的元素类型信息。擦除是允许泛型类型与不使用泛型的遗留代码（第 26 项）自由互操作的原因，确保在 Java 5 中平滑过渡到泛型。

&emsp;&emsp;由于上述这些根本的区别，因此数组和泛型不能很好地混合使用。例如，创建泛型、参数化类型或者类型参数的数组是非法的。这些数组创建表达式没有一个是合法的：`new List<E>[], new List<String>[], new E[]`。这些在编译时都会导致一个*泛型数组创建（generic array creation）* 错误。

&emsp;&emsp;为什么创建泛型数组是非法的？因为它不是类型安全的。要是它合法，编译器在其他正确的程序中发生的转换就会在运行时失败，并出现一个`ClassCastException`异常。这就违背了泛型系统提供的基本保证。

&emsp;&emsp;为了更加具体地对此进行说明，考虑以下代码片段：

```java
// Why generic array creation is illegal - won't compile!
List<String>[] stringLists = new List<String>[1]; // (1)
List<Integer> intList = List.of(42); // (2)
Object[] objects = stringLists; // (3)
objects[0] = intList; // (4)
String s = stringLists[0].get(0); // (5)
```

&emsp;&emsp;我们假设第 1 行是合法的，它创建了一个泛型数组。第 2 行创建并初始化了一个包含单个元素的 List\<Integer\>。第 3 行将 List\<String\>数组保存到 Object 数组里唯一的元素中，这是合法的，因为数组是协变的。第 4 行将 List\<Integer\>保存到 Object 数组里唯一的元素中，这是可以的，因为泛型是通过擦除实现的：List\<Integer\>实例的运行时类型只是 List，List\<String\>\[\]实例的运行时类型则是 List\[\]，因此这种安排不会产生`ArrayStoreException`异常。但现在我们有麻烦了。我们将一个 List\<Integer\>实例保存到了原本声明只包含 List\<String\>实例的数组中。在第 5 行中，我们从这个数组里唯一的列表中获取了唯一的元素。编译器自动地将获取到地元素转换成 String，但它是一个 Integer，因此，我们在运行时得到了一个`ClassCastException`异常。为了防止出现这种情况，（创建泛型数组）第 1 行产生了一个编译时错误。

&emsp;&emsp;从技术的角度上来说，像 E、List\<E\>和 List\<String\>这样的类型应称作*不可具体化的（non-reifiable）* 类型[JLS, 4.7]。直观地说，不可具体化（non-reifiable）的类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。由于擦除的原因，唯一可具体化的（reifiable）参数化类型是无限制的通配符类型，如 List\<?\>和Map\<?,?\>（第 26 项）。虽然不常用，但是创建无限制通配类型的数组是合法的。

&emsp;&emsp;禁止创建泛型数组可能有点讨厌。例如，这表明泛型一般不可能返回它的元素类型数组（部分解决方案请见第 33 项）。这也意味着在结合使用可变参数（varargs）方法（见第 53 项）和泛型时会出现令人费解的警告。这是由于每当调用可变参数方法时，就会创建一个数组来存放 varargs 参数，如果这个数组的元素类型不是可具体化的（reifialbe），就会得到一条警告。SafeVarargs 注释可用于解决此问题（第 32 项）。

&emsp;&emsp;当你在转换为数组类型时获得泛型数组创建错误或未经检查的强制转换警告时，最佳解决方案通常是优先使用集合类型 List\<E\>而不是数组类型 E\[\]。你可能会牺牲一些简洁性或性能，但是换回的却是更高的类型安全性和互用性。

&emsp;&emsp;例如，假设你要编写一个 Chooser 类，其中包含一个带有集合的构造函数，以及一个返回随机选择的集合元素的方法。根据你传递给构造函数的集合，你可以使用 chooser 作为游戏骰子、魔术 8 球或蒙特卡罗模拟的数据源。这是一个没有泛型的简单实现：

```java
// Chooser - a class badly in need of generics!
public class Chooser {
    private final Object[] choiceArray;
    public Chooser(Collection choices) {
        choiceArray = choices.toArray();
    }
    public Object choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceArray[rnd.nextInt(choiceArray.length)];
    }
}
```

&emsp;&emsp;要使用此类，每次使用调用方法时都必须将 choose 方法的返回值从 Object 转换为所需要类型，如果类型错误，则在运行时将转换失败。将第 29 项的建议铭记于心，我们试图修改 chooser 以使其成为通用的。 更改后大概如下显示：

```java
// A first cut at making Chooser generic - won't compile
public class Chooser<T> {
    private final T[] choiceArray;
    public Chooser(Collection<T> choices) {
        choiceArray = choices.toArray();
    }
    // choose method unchanged
}
```

&emsp;&emsp;如果你尝试编译这个类，你会得到这样的错误信息：

```java
Chooser.java:9: error: incompatible types: Object[] cannot be
converted to T[]
    choiceArray = choices.toArray();
                                ^
 where T is a type-variable:
    T extends Object declared in class Chooser
```

&emsp;&emsp;没什么大不了，你会说，我会将 Object 数组转换为 T 数组：

```java
choiceArray = (T[]) choices.toArray();
```

&emsp;&emsp;这摆脱了错误，但你得到一个警告：

```java
Chooser.java:9: warning: [unchecked] unchecked cast
    choiceArray = (T[]) choices.toArray();
                                       ^
 required: T[], found: Object[]
 where T is a type-variable:
T extends Object declared in class Chooser
```

&emsp;&emsp;编译器告诉你它无法在运行时保证强制转换的安全性，因为程序不知道 T 代表什么类型，记住，元素类型信息在运行时会从泛型中删除。这个程序是否可以正常工作？是的，但是编译器无法证明这一点。你可以自己证明它，将证据放在注释中并使用注释来抑制警告，但最好消除导致警告的原因（第 27 项）。

&emsp;&emsp;要消除未检查的强制类型转换警告，请使用列表而不是数组。以下是 Chooser 类的一个版本，它可以编译而不出现错误或警告：

```java
// List-based Chooser - typesafe
public class Chooser<T> {
    private final List<T> choiceList;
    public Chooser(Collection<T> choices) {
        choiceList = new ArrayList<>(choices);
    }
    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}
```

&emsp;&emsp;这个版本有点冗长，也许有点慢，但是为了让你高枕无忧，你不会在运行时获得`ClassCastException`异常。

&emsp;&emsp;总之，数组和泛型具有非常不同的类型规则。数组是协变的和可具体化的; 泛型是不变的且可以被擦除。因此，数组提供运行时的类型安全，但不提供编译时的类型安全，反之，对于泛型也一样。通常，数组和泛型不能很好地混合使用。如果你发现自己将它们混合起来使用，并且得到了编译时错误或警告，你的第一个反应就应该是用列表替换数组。



# 优先考虑泛型

&emsp;&emsp;一般来说参数化声明并使用 JDK 提供的泛型和方法通常并不困难。编写自己的泛型会比较困难一些，但是值得花些时间去学习如何编写。

&emsp;&emsp;考虑到第 7 项中这个简单（玩具）堆栈的实现：

```java
// Object-based collection - a prime candidate for generics
public class Stack {

    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    private void ensureCapacity() {
        if (elements.length == size)
        elements = Arrays.copyOf(elements, 2 * size + 1);
    }
}
```

&emsp;&emsp;这个类一开始就应该被参数化，但既然不是这样的，那么我们接下来就可以对它泛型化（generify）。换句话说我们可以参数化它而不会损害原始非参数化版本的客户端。就目前而言，必须转换从堆栈里弹出来的对象，以及可能在运行时失败的那些转换。将类泛型化的第一个步骤是给它的声明添加一个或者多个类型参数。在这个例子中有一个类型参数，它表示堆栈的元素类型，这个参数的名称通常为 E（第 68 项）。

&emsp;&emsp;下一步是用相应的类型参数替换所有的 Object 类型，然后试着编译最终的程序：

```java
// Initial attempt to generify Stack - won't compile!
public class Stack<E> {

    private E[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new E[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(E e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public E pop() {
        if (size == 0)
            throw new EmptyStackException();
        E result = elements[--size];
        elements[size] = null; // Eliminate obsolete reference
        return result;
    }

    ... // no changes in isEmpty or ensureCapacity
}
```

&emsp;&emsp;通常，你将至少得到一个错误或者警告，这个类也不例外。幸运的是，这个类只产生一个错误，如下：

```java
    Stack.java:8: generic array creation
        elements = new E[DEFAULT_INITIAL_CAPACITY];
```

&emsp;&emsp;如第 28 项所描述的，你不能创建不可具体化的（non-reifiable）类型的数组，如 E。每当编写用数组支持的泛型时，都会出现这个问题。解决这个问题有两种方法。第一种，直接绕过创建泛型数组的禁令：创建一个 Object 的数组，并将它转换成泛型数组类型。现在错误是消除了，但是编译器会产生一条警告。这种用法是合法的，但（整体上而言）不是类型安全的：

```java
Stack.java:8: warning: [unchecked] unchecked cast
found: Object[], required: E[]
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
                  ^
```

&emsp;&emsp;编译器不可能证明你的程序是类型安全的，但是你可以证明。你自己必须确保未受检的转换不会危及到程序的类型安全性。问题中的数组(elements)被保存在一个私有的域中，永远不会被返回到客户端，或者传给任何其他方法。这个数组中保存的唯一元素，是传给 push 方法的那些元素，它们的类型为 E，因此未受检的转换不会有任何危害。

&emsp;&emsp;一旦你证明了未受检的转换是安全的，就要在尽可能小的范围中禁止警告（第 27 项）。在这种情况下，构造器只包含未受检的数组创建，因此可以在整个构造器中禁止这条警告。通过增加一条注解来完成禁止，Stack 能够正确无误地进行编译，你就可以使用它了，无需显示的转换，也无需担心会出现 ClassCastException 异常：

```java
// The elements array will contain only E instances from push(E).
// This is sufficient to ensure type safety, but the runtime
// type of the array won't be E[]; it will always be Object[]!
@SuppressWarnings("unchecked")
public Stack() {
    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
}
```

&emsp;&emsp;消除 Stack 中泛型数组创建错误的第二种方法是，将 elements 域的类型从 E[]改为 Object[]。这么做会得到一条不同的错误：

```java
Stack.java:19: incompatible types
found: Object, required: E
    E result = elements[--size];
```

&emsp;&emsp;通过把数组中获取到的元素由 Object 转换成 E，可以将这条错误变成一条警告：

```java
Stack.java:19: warning: [unchecked] unchecked cast
found: Object, required: E
    E result = (E) elements[--size];
                            ^
```

&emsp;&emsp;由于 E 是一个不可具体化的（non-reifiable）类型，编译器无法在运行时检验转换。同样，你可以轻松地向自己证明未受检的转换是安全的，因此可以禁止该警告。根据第 27 项的建议，我们只要在包含未受检转换的赋值上禁止警告，而不是在整个 pop 方法上就可以了，如下：

```java
// Appropriate suppression of unchecked warning
public E pop() {
    if (size == 0)
        throw new EmptyStackException();
    // push requires elements to be of type E, so cast is correct
    @SuppressWarnings("unchecked")
    E result = (E) elements[--size];
    elements[size] = null; // Eliminate obsolete reference
    return result;
}
```

&emsp;&emsp;消除通用数组创建的这两种技术都有它们的支持者。第一个更具有可读性：数组声明为 E[]类型，清楚地表明它只包含 E 实例。它也更简洁：在典型的泛型类中，你可以在代码中的很多地方读取数组；第一种技术只需要一次转换（创建数组的位置），而第二种技术每次读取数组元素时都需要单独的转换。因此，优选第一种，并且在实践中更常用第一种。但是，它会导致堆污染（heap pollution）（第 32 项）：数组的运行时类型与其编译时的类型不匹配（除非 E 恰好是 Object）。这使得一些程序猿非常不安，他们选择第二种技术，尽管在这种情况下堆污染是无害的。

&emsp;&emsp;下面的程序示范了泛型 Stack 类的使用。程序以相反的顺序打印出它的命令行参数，并转换成大写字母。如果要在从堆栈中弹出的元素上调用 String 的`toUpperCase`方法，并不需要显式的转换，并且会确保自动生成的转换会成功：

```java
// Little program to exercise our generic Stack
public static void main(String[] args) {
    Stack<String> stack = new Stack<>();
    for (String arg : args)
        stack.push(arg);
    while (!stack.isEmpty())
        System.out.println(stack.pop().toUpperCase());
}
```

&emsp;&emsp;上面的示例可能看起来与第 28 项相矛盾，第 28 项鼓励优先使用列表而不是数组。在泛型中使用列表并不总是可行或可取的。Java 并不是生来就支持列表，因此有些泛型如 ArrayList，则必须在数组上实现。为了提升性能，其他泛型如 HashMap 也在数组上实现。

&emsp;&emsp;绝大多数泛型与我们的 Stack 示例类似，因为它们的类型参数没有限制：你可以创建 Stack\<Object\>、Stack\<int[]\>、Stack\<List\<String\>\>，或者任何其他对象引用类型的 Stack。注意，不能创建基本类型的 Stack：企图创建 Stack\<int\>或者 Stack\<double\>会产生一个编译时错误。这是 Java 泛型系统根本的局限性。你可以通过使用基本包装类型（boxed primitive type）来避开这条限制（第 61 项）。

&emsp;&emsp;有一些泛型限制了可允许的类型参数值。例如，考虑 java.util.concurrent.DelayQueue，其声明如下：

```java
class DelayQueue<E extends Delayed> implements BlockingQueue<E>
```

&emsp;&emsp;类型参数列表（\<E extends Delayed\>）要求实际的类型参数 E 必须是 java.util.concurrent.Delayed 的一个子类型。它允许 DelayQueue 实现以及客户端在 DelayQueue 的元素上利用 Delayed 方法，无需显示的转换，也没有出现 ClassCastException 的风险。类型参数 E 被称为有限制的类型参数（ bounded type parameter）。注意，子类型关系确定了，每个类型都是它自身的子类型[JLS, 4.10]，因此创建 DelayQueue\[Delayed\]是合法的。

&emsp;&emsp;总而言之，使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。在设计新类型的时候，要确保它们不需要这种转换就可以使用。这通常意味着要把类做成泛型。如果你现在有任何类型应该是通用的但却不是通用的，就把现有的类型都泛型化。这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端（第 26 项）。





## 用 enum 代替 int 常量

&emsp;&emsp;枚举类型（enum type）是指由一组固定的常量组成合法值的类型，例如一年中的季节、太阳系中的行星或者一副扑克牌中的花色。在编程语言中还没有引入枚举类型之前，表示枚举类型的常用模式是声明一组具名的 int 常量，每个类型成员一个常量：

```java
    // The int enum pattern - severely deficient!
    public static final int APPLE_FUJI = 0;
    public static final int APPLE_PIPPIN = 1;
    public static final int APPLE_GRANNY_SMITH = 2;
    public static final int ORANGE_NAVEL = 0;
    public static final int ORANGE_TEMPLE = 1;
    public static final int ORANGE_BLOOD = 2;
```

&emsp;&emsp;这种方法称作 int 枚举模式（int enum type），存在着诸多不足。它在类型安全方面没有任何帮助，表达能力不足。如果你将 apple 传到想要 orange 的方法中，编译器也不会出现警告，还可以用==操作符将 apple 和 orange 进行对比，甚至更糟糕：

```java
// Tasty citrus flavored applesauce!
int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;
```

&emsp;&emsp;注意每个 apple 常量的名称都以 APPLE\_作为前缀，每个 orange 常量则以 ORANGE\_作为前缀。这是因为 Java 没有为 int 枚举组提供命名空间。当两个 int 枚举具有相同的命名常量时，前缀可以防止名称发生冲突，例如在`ELEMENT_MERCURY`和`PLANET_MERCURY`之间。

&emsp;&emsp;采用 int 枚举模式的程序是十分脆弱的。因为 int 枚举是常量变量(constant variables)[JLS, 4.12.4]，所以它们的 int 值被编译到使用它们的客户端[JLS, 13.1]。如果与枚举常量关联的 int 发生了变化，客户端就必须重新编译。如果没有重新编译，程序还是可以运行，但是它们的行为就是不确定的。

&emsp;&emsp;将 int 枚举常量翻译成可打印的字符串，并没有很便利的方法。如果将这种常量打印出来或者从调试器中将它显示出来，你所见到的就是一个数字，这没有太大的用处。要遍历一个组中的所有 int 枚举常量，甚至获得 int 枚举组的大小，这些都没有很可靠的方法。

&emsp;&emsp;你还可能碰到这种模式的变体，在这种模式中使用的是 String 常量，而不是 int 常量。这样的变体被称作 String 枚举模式，同样也是我们最不期望的。虽然它为这些常量提供了可打印字符串，但是它会导致性能问题，因为它依赖于字符串的比较操作。更糟糕的是，它会导致初级用户把字符串常量硬编码到客户端代码中，而不是使用适当的域（field）名。如果这样的硬编码字符串常量中包含书写错误，那么，这样的错误在编译时不会被检测到，但是在运行的时候却会报错。

&emsp;&emsp;幸运的是，Java 提供了一种可以替代的解决方案，可以避免 int 和 String 枚举模式的缺点，并提供许多额外的好处。这就是枚举类型[JLS, 8.9]。下面以最简单的形式演示了这种模式：

```java
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
```

&emsp;&emsp;表面上看，这些枚举类型与其他语言中的没什么两样，例如 C、C++和 C#，但是实际上并非如此。Java 的枚举类型是功能十分齐全的类，功能比其他语言中的对等物要更强大得多，Java 的枚举本质上是 int 值。

&emsp;&emsp;Java 枚举类型背后的基本想法非常简单：它们就是通过公有的静态 final 域为每个枚举常量导出的实例的类。因为没有可以访问的构造器，枚举类型是真正的 final。因为客户端既不能创建枚举类型的实例，也不能对它进行扩展，因此很可能没有实例，而只有声明过的枚举常量。换句话说，枚举类型是实例是受控制的（原书第 6 页）。它们是单例（Singleton）的泛型化（第 3 项），本质上是单元素枚举。

&emsp;&emsp;枚举提供了编译时的类型安全。如果声明一个参数的类型为 Apple，就可以保证，被传到该参数上的任何非 null 的对象引用一定属于三个有效的 Apple 值之一。试图传递类型错误的值时，会导致编译时错误，就像试图将某种枚举类型的表达式赋给另一种枚举类型的变量，或者试图利用==操作符比较不同枚举类型的值一样。

&emsp;&emsp;包含同名常量的多个枚举类型可以在一个系统中和平共处，因为每个类型都有自己的命名空间，你可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码，因为导出常量的域在枚举类型和它的客户端之间提供了一个隔离层：常量值并没有被编译到客户端代码中，而是在 int 枚举模式中，最终，可以通过调用 toString 方法，将枚举转换成可打印的字符串。

&emsp;&emsp;除了完善了 int 枚举模式的不足之外，枚举类型还允许添加任意的方法和域，并实现任意的接口。它们提供了所有 Object 方法（第 3 章），实现了 Comparable（第 14 项）和 Serializable（第 12 章），并针对枚举类型的可任意改变性设计了序列化方式。

&emsp;&emsp;那么我们为什么要将方法或者域添加到枚举类型中呢？首先，你可能是想将数据与它的常量关联起来。例如，一个能够返回水果颜色或者返回水果图片的方法，对于我们的 Apple 和 Orange 类型来说可能很有好处。你可以利用任何适当的方法来增强枚举类型。枚举类型可以先作为枚举常量的一个简单集合，随着时间的推移再演变成为全功能的抽象。

&emsp;&emsp;举个有关枚举类型的好例子，比如太阳系中的 8 颗行星。每颗行星都有质量和半径，通过这两个属性可以计算出它的表面重力。从而给定物体的质量，就可以计算出一个物体在行星表面上的重量。下面就是这个枚举。每个枚举常量后面括号中的数值就是传递给构造器的参数。在这个例子中，它们就是行星的质量和半径：

```java
// Enum type with data and behavior
public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS (4.869e+24, 6.052e6),
    EARTH (5.975e+24, 6.378e6),
    MARS (6.419e+23, 3.393e6),
    JUPITER(1.899e+27, 7.149e7),
    SATURN (5.685e+26, 6.027e7),
    URANUS (8.683e+25, 2.556e7),
    NEPTUNE(1.024e+26, 2.477e7);
    private final double mass; // In kilograms
    private final double radius; // In meters
    private final double surfaceGravity; // In m / s^2
    // Universal gravitational constant in m^3 / kg s^2
    private static final double G = 6.67300E-11;
    // Constructor
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }
    public double mass() { return mass; }
    public double radius() { return radius; }
    public double surfaceGravity() { return surfaceGravity; }
    public double surfaceWeight(double mass) {
        return mass * surfaceGravity; // F = ma
    }
}
```

&emsp;&emsp;编写一个像 Planet 这样的枚举类型并不难。**为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器**。枚举天生就是不可变的，因此所有的域都应该为 final 的（第 17 项）。它们可以是公有的，但最好将它们做成是私有的，并提供公有的访问方法（第 16 项）。在 Planet 这个示例中，构造器还计算和保存表面重力，但这正是一种优化。每当 surfaceWeight 方法用到重力时，都会根据质量和半径重新计算，并返回它在该常量所表示的行星上的重量。

&emsp;&emsp;虽然 Planet 枚举很简单，它的功能却强大得出奇。下面是一个简短的程序，根据某个物体在地球上的重量（以任何单位），打印出一张很棒的表格，显示出该物体在所有 8 颗行星上的重量（用相同的单位）：

```java
public class WeightTable {
    public static void main(String[] args) {
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight / Planet.EARTH.surfaceGravity();
        for (Planet p : Planet.values())
            System.out.printf("Weight on %s is %f%n", p, p.surfaceWeight(mass));
        }
}
```

&emsp;&emsp;注意 Planet 就像所有的枚举一样，它有一个静态的 values 方法，按照声明顺序返回它的值数组。还要注意 toString 方法返回每个枚举值的声明名称，使得 println 和 printf 的打印变得更加容易。如果你不满意这种字符串表示法，可以通过覆盖 toString 方法对它进行修改。下面就是用命令行参数 185 运行这个 WeightTable 程序（没有重写 toString 方法）时的结果：

```
Weight on MERCURY is 69.912739
Weight on VENUS is 167.434436
Weight on EARTH is 185.000000
Weight on MARS is 70.226739
Weight on JUPITER is 467.990696
Weight on SATURN is 197.120111
Weight on URANUS is 167.398264
Weight on NEPTUNE is 210.208751
```

&emsp;&emsp;直到 2006 年，在枚举类型被添加到 Java 之后两年，冥王星才是一颗行星。这提出了一个问题“当你从枚举类型中删除一个元素会发生什么？”答案是任何不引用被删除的元素的客户端程序都将继续正常工作。因此，例如，我们的 WeightTable 程序只会打印一个少一行的表。什么是客户端程序引用被删除的元素（在本例中为 Planet.Pluto)？如果重新编译客户端程序，编译将失败，并在引用以前行星的【代码】行中显示有用的错误信息；如果你无法重新编译客户端，它将在运行时引发一个有用的异常。这可能是你希望的最佳行为，远远优先于你使用 int 枚举模式获得的行为。

&emsp;&emsp;与枚举常量关联的有些行为，可能只需要在定义了枚举的类或者包中。这种行为最好被实现成私有的或者包级私有的方法。然后，每个枚举常量都带有一组隐蔽的行为，这使得包含该枚举的类或者包在遇到这种常量时都可以做出适当的反应。就像其他的类一样，除非迫不得已要将枚举方法导出至它的客户端，否则都应该将它声明为私有的，如有必要，则声明为包级私有的（第 15 项）。

&emsp;&emsp;如果一个枚举具有普遍的适用性，它就应该成为一个顶级类（top-level class）；如果它只是被用在一个特定的顶级类中，他就应该成为该顶级类的一个成员类（第 24 项）。例如，java.math.RoundingMode 枚举表示十进制小数的舍入模式（rounding mode）。这些舍入模式用于 BigDecimal 类，但是它们提供了一个非常有用的抽象，这种抽象本质上又不属于 BigDecimal 类。通过使用 RoundingMode 变成一个顶级类，库的设计者鼓励任何需要舍入模式的程序猿重用这个枚举，从而增强 API 之间的一致性。

&emsp;&emsp;Planet 示例中所示的方法对于大多数枚举类型来说就足够了，但你有时候会需要更多的方法。每个 Planet 常量都关联了不同的数据，但你有时候需要将本质上不同的行为（behavior）与每个常量关联起来。例如，假设你在编写一个枚举类型，来表示计算器的四大基本操作（即加减乘除），你想要提供一个方法来执行每个常量所表示的算术运算。有一种方法是通过启用枚举的值来实现：

```java
// Enum type that switches on its own value - questionable
public enum Operation {
    PLUS, MINUS, TIMES, DIVIDE;
    // Do the arithmetic operation represented by this constant
    public double apply(double x, double y) {
        switch(this) {
            case PLUS: return x + y;
            case MINUS: return x - y;
            case TIMES: return x * y;
            case DIVIDE: return x / y;
        }
        throw new AssertionError("Unknown op: " + this);
    }
}
```

&emsp;&emsp;这段代码是可行的，但是不太好看。如果没有 throw 语句，他就不能进行编译，虽然从技术角度来看代码的结束部分是可以执行到的，但是实际上是不可能执行到这行代码的[JLS, 14.21]。更糟糕的是，这段代码很脆弱。如果你添加了新的枚举常量，却忘记给 switch 添加相应的条件，枚举仍然是可以编译的，但是当你试图运用新的运算时，就会运行失败。

&emsp;&emsp;幸运的是，有一种更好的方法可以将不同的行为与每个枚举常量关联起来：在枚举类型中声明一个抽象的 apply 方法，并在特定于常量的类主体（constant-specific class body）中，用具体方法覆盖每个常量的抽象 apply 方法。这种方法被称作特定于常量的方法实现（constant-specific method implementations）：

```java
// Enum type with constant-specific method implementations
public enum Operation {
    PLUS {public double apply(double x, double y){return x + y;}},
    MINUS {public double apply(double x, double y){return x - y;}},
    TIMES {public double apply(double x, double y){return x * y;}},
    DIVIDE {public double apply(double x, double y){return x / y;}};
    public abstract double apply(double x, double y);
}
```

&emsp;&emsp;如果你在 Operation 的第二个版本中添加新的常量，你就不可能忘记提供 apply 方法，因为该方法就紧跟在每个常量声明之后。即使你真的忘记了，编译器也会提醒你，因为枚举类型中的抽象方法必须被它所有常量中的具体方法所覆盖。

&emsp;&emsp;特定于常量的方法实现可以与特定于常量的数据结合起来。例如，下面的 Operation 覆盖了 toString 来返回通常与该操作相关联的符号：

```java
// Enum type with constant-specific class bodies and data
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) { return x / y; }
    };
    private final String symbol;
    Operation(String symbol) { this.symbol = symbol; }
    @Override
    public String toString() { return symbol; }
    public abstract double apply(double x, double y);
}
```

&emsp;&emsp;在有些情况下，在枚举中覆盖 toString 非常有用。例如，上述的 toString 实现使得打印算术表达式变得非常容易，如这段小程序所示：

```java
public static void main(String[] args) {
    double x = Double.parseDouble(args[0]);
    double y = Double.parseDouble(args[1]);
    for (Operation op : Operation.values())
        System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
}
```

&emsp;&emsp;用 2 和 4 作为命令行参数运行这段程序，会输出：

```
2.000000 + 4.000000 = 6.000000
2.000000 - 4.000000 = -2.000000
2.000000 * 4.000000 = 8.000000
2.000000 / 4.000000 = 0.500000
```

&emsp;&emsp;枚举类型有一个自动产生的 valueOf(String)方法，它将常量的名字转变成常量本身。如果在枚举类型中覆盖 toString，要考虑编写一个 fromString 方法，将定制的字符串表示法变回相应的枚举。下列代码（适当地改变了类型名称）可以为任何枚举完成这一技巧，只要每个常量都有一个独特的字符串表示法：

```java
// Implementing a fromString method on an enum type
private static final Map<String, Operation> stringToEnum = Stream.of(values()).collect(toMap(Object::toString, e -> e));
// Returns Operation for string, if any
public static Optional<Operation> fromString(String symbol) {
    return Optional.ofNullable(stringToEnum.get(symbol));
}
```

&emsp;&emsp;注意，在枚举常量被创建之后，Operation 常量就会被放入一个已经初始化了的静态域 stringToEnum 的 map 中。前面的代码使用了一个 stream（第 7 章），而不是 values()方法返回的数组（The previous code uses a stream (Chapter 7) over the array returned by the values() method）；在 Java 8 之前，我们将创建一个空的哈希映射（hash map），并遍历 values 数组，将字符串跟枚举的映射插入一个 map 中，如果你愿意，仍然可以这样做。但请注意，试图使每个常量都从自己的构造器将自身放入到 map 中是不会起作用的。这会导致编译时错误，这是好事，因为如果它是合法的，它将在运行时导致 NullPointerException。除常量变量外不允许枚举构造函数访问枚举的静态字段（第 34 项）。这种限制是必要的，因为枚举构造函数运行时尚未初始化静态字段。这种限制的一个特例是枚举常量不能从它们的构造函数中相互访问（A special case of this restriction is that enum constants cannot access one another from their constructors.）。

&emsp;&emsp;另外请注意，fromString 方法返回 Optional<String>。这表示允许该方法传入的字符串不表示有效操作，并且它强制客户端面对这种可能性（第 55 项）。

&emsp;&emsp;特定于常量的方法实现有一个美中不足的地方，它们使得在枚举常量中共享代码变得更加困难了。例如，考虑用一个枚举表示薪资中的工作天数。这个枚举有一个方法，根据给定某工人的基本工资（按小时）和当天工作的分钟数计算当天工人的工资。在五个工作日，任何超过正常班次的工作都会产生加班费; 在两个周末的日子里，所有工作都会产生加班费。使用 switch 语句，通过将多个案例标签应用于两个代码片段中的每一个，可以轻松地进行此计算：

```java
// Enum that switches on its value to share code - questionable
enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    private static final int MINS_PER_SHIFT = 8 * 60;
    int pay(int minutesWorked, int payRate) {
        int basePay = minutesWorked * payRate;
        int overtimePay;
        switch(this) {
            case SATURDAY: case SUNDAY: // Weekend
                overtimePay = basePay / 2;
            break;
            default: // Weekday
                overtimePay = minutesWorked <= MINS_PER_SHIFT ? 0 : (minutesWorked - MINS_PER_SHIFT) * payRate / 2;
        }
        return basePay + overtimePay;
    }
}
```

&emsp;&emsp;毫无疑问，这段代码是简洁的，但从维护的角度来看，它是非常危险的。假设将一个元素添加到该枚举中，或许是一个表示假期天数的特殊值，但是忘记给 switch 语句添加相应的 case。程序依然可以编译，但 pay 方法会悄悄地将假期的工资计算成与正常工作日的相同。

&emsp;&emsp;为了利用特定于常量的方法实现安全地执行工资计算，你可能必须重复计算每个常量的加班工资，或者将计算移到两个辅助方法中（一个用来计算工作日，一个用来计算双休日），并从每个常量调用相应的辅助方法。这任何一种方法都会产生相当数量的样板代码，结果降低了可读性，并增加了出错的机率。

&emsp;&emsp;通过用计算工作日加班工资的具体方法代替 PayrollDay 中抽象的 overtimePay 方法，可以减少样板代码。这样，就只有双休日必须覆盖该方法了。但是这样也有着与 switch 语句一样的不足：如果又增加了一天而没有覆盖 overtimePay 方法，就会悄悄地延续工作日的计算。

&emsp;&emsp;你真正想要的就是每当添加一个枚举常量时，就强制选择一种加班报酬。幸运的是，有一种很好的方法可以实现这一点。这种想法就是将加班工资计算移到一个私有的嵌套枚举中，将这个枚举策略（strategy enum）的实例传到 PayrollDay 枚举的构造器中。之后 PayrollDay 枚举将加班工资计算委托给策略枚举，PayrollDay 中就不需要 switch 语句或者特定于常量的方法实现了。虽然这种模式没有 switch 语句那么简洁，但更加安全，也更加灵活：

```java
// The strategy enum pattern
enum PayrollDay {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,
    SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);
    private final PayType payType;
    PayrollDay(PayType payType) { this.payType = payType; }
    PayrollDay() { this(PayType.WEEKDAY); } // Default
    int pay(int minutesWorked, int payRate) {
        return payType.pay(minutesWorked, payRate);
    }
    // The strategy enum type
    private enum PayType {
        WEEKDAY {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked <= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2;
            }
        },
        WEEKEND {
            int overtimePay(int minsWorked, int payRate) {
                return minsWorked * payRate / 2;
            }
        };
        abstract int overtimePay(int mins, int payRate);
        private static final int MINS_PER_SHIFT = 8 * 60;
        int pay(int minsWorked, int payRate) {
        int basePay = minsWorked * payRate;
            return basePay + overtimePay(minsWorked, payRate);
        }
    }
}
```

&emsp;&emsp;如果枚举中的 switch 语句不是在枚举中实现特定于常量的行为的一种很好的选择，那么它们还有什么用处呢？**枚举中的 switch 语句适合给外部的枚举类型增加特定于常量的行为**。例如，假设 Operation 枚举不受你的控制，你希望它有一个实例方法来返回每个运算的反运算。你可以用下列静态方法模拟这种效果：

```java
// Switch on an enum to simulate a missing method
public static Operation inverse(Operation op) {
    switch(op) {
        case PLUS: return Operation.MINUS;
        case MINUS: return Operation.PLUS;
        case TIMES: return Operation.DIVIDE;
        case DIVIDE: return Operation.TIMES;
        default: throw new AssertionError("Unknown op: " + op);
    }
}
```

&emsp;&emsp;如果方法根本不属于枚举类型，那么你应该在可控制的枚举类型上使用该技巧。该方法可能有某些用途，但不足以证明它应该包含在枚举类型中。

&emsp;&emsp;一般来说，枚举在性能上与 int 常量差不多。枚举的一个小小的性能缺点就是在加载和初始化枚举类型会有空间和时间成本，但在实践中不必太在意。

&emsp;&emsp;那么什么时候应该使用枚举呢？**只要有一组在编译时就是已知的成员常量，就可以使用枚举**。当然，这包括“自然枚举类型”，例如，行星，星期几和棋子。但也包括其他集合，您可以在编译时了解所有可能的值，例如，菜单上的选项，操作代码和命令行标志。**枚举类型中的常量集不必一直保持固定**。枚举功能专门设计用于允许枚举类型的二进制兼容演变。

&emsp;&emsp;总之，枚举类型跟 int 常量相比，优点是显而易见的。枚举更具有可读性，更安全，更强大。许多枚举不需要显示构造函数或成员，但许多枚举则受益于将每个常量与数据【枚举的成员】相关联并提供这个数据影响行为的方法。在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个枚举常量同时共享相同的行为，则考虑策略枚举。

## 用实例域代替序数

&emsp;&emsp;许多枚举天生就与一个单独的 int 值相关联。所有的枚举都有一个 ordinal 方法，它返回每个枚举常量在类型中的数字位置。你可以试着从序数中得到关联的 int 值：

```java
// Abuse of ordinal to derive an associated value - DON'T DO THIS
public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;
    public int numberOfMusicians() { return ordinal() + 1; }
}
```

&emsp;&emsp;虽然这个枚举不错，但是维护起来就像一场噩梦。如果常量进行重新排序，numberOfMusicians 方法就会遭到破坏。如果要再添加一个与已经用过的 int 值关联的枚举常量，就没那么走运了。例如，给双四重奏（double quartet）添加一个常量，它就像个八重奏一样，是由 8 位演奏家组成，但这是没办法做到的。

&emsp;&emsp;要是没有给这些所有的 int 值添加常量，也就无法给某个 int 值添加常量。例如，假设想要添加一个常量表示三重奏（triple quartet），它由 12 位演奏家组成。对于由 11 位演奏家组成的合奏曲并没有标准的术语，因此只好给没有用过的 int 值（11）添加一个虚拟（dummy）常量。这么做顶多就是不太好看。如果有许多 int 值都是从未用过的，可就不切实际了。

&emsp;&emsp;幸运的是，有一种很简单的方法可以解决这些问题。**永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中**：

```java
public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
    NONET(9), DECTET(10), TRIPLE_QUARTET(12);
    private final int numberOfMusicians;
    Ensemble(int size) { this.numberOfMusicians = size; }
    public int numberOfMusicians() { return numberOfMusicians; }
}
```

&emsp;&emsp;Enum 规范中谈到 ordinal 时是这么写的：“大多数程序猿都不需要这个方法。它这么设计的目的是用于像 EnumSet 和 EnumMap 这种基于枚举的通用数据结构的。”除非你在编写的是这种数据结构，否则最好避免使用 ordinal 方法。

# 注解优于命名模式

&emsp;&emsp;在之前的做法中（Historically），一般使用*命名模式（naming pattern）* 表明有些程序元素需要通过某种工具或者框架进行特殊处理。例如，在第 4 版之前，JUnit 测试框架要求其用户通过使用字符 test 作为测试方法名称的开头\[Beck04\]。这种方法可行，但它有几个很大的缺点。首先，文字拼写错误会导致失败，并且没有任何提示。例如，假设你不小心将测试方法命名为 tsetSafetyOverride 而不是 testSafetyOverride。Junit 3 不会出错，但是它也不会执行测试，造成错误的安全感【也就是说，那个命名错误的测试方法不会执行测试，并且不会报错，让我们误以为测试成功了】。

&emsp;&emsp;命名模式的第二个缺点是，无法确保它们只用于相应的程序元素上。例如，假设你将某个类命名为 TestSafetyMechanisms ，是希望 JUnit 3 会自动测试它所有的方法，而不管它们叫什么名称。Junit 3 还是不会出错，但也同样不会执行测试。

&emsp;&emsp;命名模式的第三个缺点是它们没有提供将参数值与程序元素相关联的好方法。例如，假设您希望支持仅在抛出特定异常时才成功的测试类别。异常类型本质上是测试的参数。您可以使用一些复杂的命名模式将异常类型名称编码到测试方法的名称中，但是这样的代码会很不雅观，也很脆弱（第 62 项）。编译器不知道要去检验准备命名异常的字符串是否真正命名成功。如果命名类不存在，或者不是一个异常，你也要试着运行测试的时候才会发现。

&emsp;&emsp;注解\[JLS，9.7\]很好地解决了这些所有的问题，JUnit 从第 4 版开始采用它。在该项中，我们将编写自己的测试框架来表明注释是如何工作的。假设想要定义一个注解类型来指定简单的测试，它们自动运行，并在抛出异常时失败。以下就是这样一个注解类型，命名为 Test:

```java
// Marker annotation type declaration
import java.lang.annotation.*;
/**
 * Indicates that the annotated method is a test method.
 * Use only on parameterless static methods.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}
```

&emsp;&emsp;Test 注解类型的声明就是它自身通过 Retention 和 Target 注解进行了注解。注解类型声明中的这种注解被称作*元注解（meta-annotation）*。@Retention(RetentionPolicy.RUNTIME)元注解表明，Test 注解应该在运行时保留。如果没有保留，测试工具就无法知道 Test 注解。@Target(ElementType.METHOD)元注解表明，Test 注解只在方法声明中才是合法的；它不能运用到类声明、域声明或者其他程序元素上。

&emsp;&emsp;注意 Test 注解声明上方的注释：“Use only on parameterless static methods.（只用于无参的静态方法）。”如果编译器能够强制这一限制最好，但是它做不到。除非你写一个注释处理器这样做。有关此专题的更多信息，请参阅 javax.annotation.processing 的文档。在缺少这样的注释处理器的情况下，如果将 Test 注解放在实例方法的声明中，或者放在带有一个或者多个参数的方法中，测试程序仍然会编译，让测试工具在运行时来处理这个问题。

&emsp;&emsp;下面就是在实践中应用 Test 注解，称作*标记注解（marker annotation）*，因为它没有参数，只是“标注”被注解的元素。如果程序猿拼错了 Test，或者将 Test 注解应用到程序元素而非方法声明，程序就无法编译：

```java
// Program containing marker annotations
public class Sample {
    @Test
    public static void m1() { } // Test should pass
    public static void m2() { }
    @Test
    public static void m3() { // Test should fail
        throw new RuntimeException("Boom");
    }
    public static void m4() { }
    @Test
    public void m5() { } // INVALID USE: nonstatic method
    public static void m6() { }
    @Test
    public static void m7() { // Test should fail
        throw new RuntimeException("Crash");
    }
    public static void m8() { }
}
```

&emsp;&emsp;这个 Sample 类有 7 个静态方法，其中有 4 个被注解为测试。在这 4 个里面，有 2 个抛出了异常：m3 和 m7，另外两个则没有：m1 和 m5。但是其中一个没有抛出异常的被注解方法：m5，是一个实例方法，因此不属于注解的有效使用。总之，Sample 包含 4 项测试：一项会通过，两项会失败，另外一项则无效。没有用 Test 注解进行标注的 4 个方法会被测试工具忽略。

&emsp;&emsp;Test 注释对 Sample 类的语义没有直接影响。它们只负责提供信息供相关的程序使用。更一般地讲，注解永远不会改变被注解代码的语义，但是使它可以通过工具进行特殊的处理，例如像这种简单的测试运行类：

```java
// Program to process marker annotations
import java.lang.reflect.*;
public class RunTests {
    public static void main(String[] args) throws Exception {
        int tests = 0;
        int passed = 0;
        Class<?> testClass = Class.forName(args[0]);
            for (Method m : testClass.getDeclaredMethods()) {
                if (m.isAnnotationPresent(Test.class)) {
                    tests++;
                try {
                    m.invoke(null);
                    passed++;
                } catch (InvocationTargetException wrappedExc) {
                    Throwable exc = wrappedExc.getCause();
                    System.out.println(m + " failed: " + exc);
                } catch (Exception exc) {
                    System.out.println("Invalid @Test: " + m);
                }
            }
        }
        System.out.printf("Passed: %d, Failed: %d%n", passed, tests - passed);
    }
}
```

&emsp;&emsp;测试运行工具在命令行上使用完全匹配的类名，并通过调用 Method.invoke 反射式地运行类中所有标注了 Test 的方法。isAnnotationPresent 方法告知该工具要运行哪些方法。如果测试方法抛出异常，并打印失败报告，包含测试的方法抛出的原始异常，该异常是使用 getCause 方法从 InvocationTargetException 中提取出来的。

&emsp;&emsp;如果尝试通过反射调用测试方法时抛出 InvocationTargetException 之外的任何异常，表明编译时没有捕捉到 Test 注解的无效用法。这种用法包括实例方法的注解，或者带有一个或者多个参数的方法的注解，或者不可访问的方法的注解。测试运行类中的第二个 cache 块捕捉到了这些 Test 用法错误，并打印出相应的错误消息。下面就是 RunTests 在 Sample 上运行时打印的输出：

```java
public static void Sample.m3() failed: RuntimeException: Boom
Invalid @Test: public void Sample.m5()
public static void Sample.m7() failed: RuntimeException: Crash
Passed: 1, Failed: 3
```

&emsp;&emsp;现在我们要针对只在抛出特殊异常时才成功的测试添加支持。为此我们需要一个新的注解类型：

```java
// Annotation type with a parameter
import java.lang.annotation.*;
/**
 * Indicates that the annotated method is a test method that
 * must throw the designated exception to succeed.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Throwable> value();
}
```

&emsp;&emsp;这个注解的参数类型是 Class<? extends Throwable>。这个通配符类型无疑很绕口。它在英语中的意思是：某个扩展 Exception 的类的 Class 对象，它允许注解的用户指定任何异常（或错误）类型。这种用法是有限制的类型令牌（第 33 项）。下面就是实际应用中的这个注解。注意类名称被用作了注解的参数值：

```java
// Program containing annotations with a parameter
public class Sample2 {
    @ExceptionTest(ArithmeticException.class)
    public static void m1() { // Test should pass
        int i = 0;
        i = i / i;
    }
    @ExceptionTest(ArithmeticException.class)
    public static void m2() { // Should fail (wrong exception)
        int[] a = new int[0];
        int i = a[1];
    }
    @ExceptionTest(ArithmeticException.class)
    public static void m3() { } // Should fail (no exception)
}
```

&emsp;&emsp;现在我们要修改一下测试运行工具来处理新的注解。这其中包括将以下代码添加到 main 方法中：

```java
if (m.isAnnotationPresent(ExceptionTest.class)) {
    tests++;
    try {
        m.invoke(null);
        System.out.printf("Test %s failed: no exception%n", m);
    } catch (InvocationTargetException wrappedEx) {
        Throwable exc = wrappedEx.getCause();
        Class<? extends Throwable> excType = m.getAnnotation(ExceptionTest.class).value();
        if (excType.isInstance(exc)) {
            passed++;
        } else {
            System.out.printf("Test %s failed: expected %s, got %s%n", m, excType.getName(), exc);
        }
    } catch (Exception exc) {
        System.out.println("Invalid @Test: " + m);
    }
}
```

&emsp;&emsp;这段代码类似于用来处理 Test 注解的代码，但有一处不同：这段代码提取了注解参数的值，并用它检验该测试抛出的异常是否为正确的类型。没有显示的转换，因此没有出现 ClassCastException 的危险。编译过的测试程序确保它的注解参数表示的是有效的异常类型，需要提醒一点：有可能注解参数在编译时是有效的，但是表示特定异常类型的类文件在运行时却不再存在。在这种希望很少出现的情况下，测试运行类会抛出 TypeNotPresentException 异常。

&emsp;&emsp;将上面的异常测试示例再深入一点，想象测试可以在抛出任何一种指定异常时都得到通过。注解机制有一种工具，使得支持这种用法变得十分容易，假设我们将 ExceptionTest 注解的参数类型改成 Class 对象的一个数组：

```java
// Annotation type with an array parameter
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTest {
    Class<? extends Exception>[] value();
}
```

&emsp;&emsp;注解中的数组参数的语法十分灵活。它是进行过优化的单元素数组。使用了 ExceptionTest 新版的数组参数之后，之前的所有 ExceptionTest 注解仍然有效，并产生单元素的数组。为了指定多元素素组，要用花括号（{}）将元素包围起来，并用逗号（,）将它们隔开：

```java
// Code containing an annotation with an array parameter
@ExceptionTest({ IndexOutOfBoundsException.class, NullPointerException.class })
public static void doublyBad() {
    List<String> list = new ArrayList<>();
    // The spec permits this method to throw either
    // IndexOutOfBoundsException or NullPointerException
    list.addAll(5, null);
}
```

&emsp;&emsp;修改测试运行工具来处理新版本的 ExceptionTest 是相当简单的。此代码替换原始版本：

```java
if (m.isAnnotationPresent(ExceptionTest.class)) {
    tests++;
    try {
        m.invoke(null);
        System.out.printf("Test %s failed: no exception%n", m);
    } catch (Throwable wrappedExc) {
        Throwable exc = wrappedExc.getCause();
        int oldPassed = passed;
        Class<? extends Exception>[] excTypes = m.getAnnotation(ExceptionTest.class).value();
        for (Class<? extends Exception> excType : excTypes) {
            if (excType.isInstance(exc)) {
                passed++;
                break;
            }
        }
        if (passed == oldPassed)
            System.out.printf("Test %s failed: %s %n", m, exc);
    }
}
```

&emsp;&emsp;从 Java 8 开始，还有另一种方法可以进行多值注释。 您可以使用@Repeatable 元注释来注释注释的声明，而不是使用数组参数声明注释类型，以表示注释可以重复应用于单个元素。此元注释采用单个参数，该参数是包含注释类型的类对象，其唯一参数是注释类型的数组\[JLS，9.6.3\]。以下我们在声明 ExceptionTest 注释上采用此方法时的样子。请注意，包含注释类型必须使用适当的保留策略和目标进行注释，否则声明将无法编译：

```java
// Repeatable annotation type
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(ExceptionTestContainer.class)
public @interface ExceptionTest {
    Class<? extends Exception> value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ExceptionTestContainer {
    ExceptionTest[] value();
}
```

&emsp;&emsp;以下是我们的 doublelyBad 测试使用重复注释代替数组值注释的方式：

```java
// Code containing a repeated annotation
@ExceptionTest(IndexOutOfBoundsException.class)
@ExceptionTest(NullPointerException.class)
public static void doublyBad() { ... }
```

&emsp;&emsp;处理可重复的注释需要小心一点。重复注释生成包含注释类型的合成注释。 getAnnotationsByType 方法掩盖了这一事实，并且可用于访问可重复注释类型的重复和非重复注释。但 isAnnotationPresent 明确指出重复注释不是注释类型，而是包含注释类型。如果一个元素具有某种类型的重复注释，并且你使用 isAnnotationPresent 方法来检查该元素是否具有该类型的注释，你将发现它没有。因此，使用此方法检查是否存在注释类型将导致程序默认忽略重复注释。同样，使用此方法检查包含注释类型将导致程序默认忽略非重复注释。要使用 isAnnotationPresent 检测重复和非重复注释，你需要检查注释类型及其包含注释类型。以下是我们的 RunTests 程序的相关部分在修改后使用 ExceptionTest 注释的可重复版本时的样子：

```java
// Processing repeatable annotations
if (m.isAnnotationPresent(ExceptionTest.class) || m.isAnnotationPresent(ExceptionTestContainer.class)) {
    tests++;
    try {
        m.invoke(null);
        System.out.printf("Test %s failed: no exception%n", m);
    } catch (Throwable wrappedExc) {
        Throwable exc = wrappedExc.getCause();
        int oldPassed = passed;
        ExceptionTest[] excTests = m.getAnnotationsByType(ExceptionTest.class);
        for (ExceptionTest excTest : excTests) {
            if (excTest.value().isInstance(exc)) {
                passed++;
                break;
            }
        }
        if (passed == oldPassed)
            System.out.printf("Test %s failed: %s %n", m, exc);
    }
}
```

&emsp;&emsp;添加了可重复的注释以提高源代码的可读性，逻辑上将相同注释类型的多个实例应用在给定的程序元素。如果你认为它们增强了源代码的可读性，请使用它们，但请记住，在声明和处理可重复的注释时有更多的样板，并且处理可重复的注释容易出错。

&emsp;&emsp;这个项目中的测试框架只是一个试验，但它清晰地证明了注释优于命名模式，它这只是揭开了注解功能的冰山一角。如果你是在编写一个需要程序猿给源文件添加信息的工具，请定义适当的注释类型。**当你可以使用注释时，根本没有理由使用命名模式**。

&emsp;&emsp;也就是说，除了“工具铁匠（toolsmiths————特定的程序猿）”之外，大多数程序猿都不必定义注解类型。**但是所有的程序猿都应该使用 Java 平台所提供的预定义的注解类型（第 40、27 项）**。还要考虑使用 IDE 或者静态分析工具所提供的任何注解。这种注解可以提升由这些工具所提供的诊断信息的质量。但是要注意这些注解还没有标准化，因此如果变换工具或者形成标准，就有很多工作要做了。

## 坚持使用 Overide 注解

&emsp;&emsp;Java 库包含多种注释类型。对于传统的程序猿，其中最重要的就是@Override。该注解只能用于方法声明，它表示被注解的方法声明会覆盖超类中的声明。如果坚持使用这个注解，可以防止一大类的非法错误。考虑下面的程序，这里的类 Bigram 表示一个*双字母组*或者有序的字母对：

```java
// Can you spot the bug?
public class Bigram {
    private final char first;
    private final char second;
    public Bigram(char first, char second) {
        this.first = first;
        this.second = second;
    }
    public boolean equals(Bigram b) {
        return b.first == first && b.second == second;
    }
    public int hashCode() {
        return 31 * first + second;
    }
    public static void main(String[] args) {
        Set<Bigram> s = new HashSet<>();
        for (int i = 0; i < 10; i++)
            for (char ch = 'a'; ch <= 'z'; ch++)
                s.add(new Bigram(ch, ch));
        System.out.println(s.size());
    }
}
```

&emsp;&emsp;main 程序反复地将 26 个双字母组添加到集合中，每个双字母组都由两个相同的小写字母组成。然后它打印出集合的大小。你可能以为程序打印出的大小为 26，因为集合不能包含重复【元素】。如果你试着运行程序，会发现它打印的不是 26 而是 260。哪里出错了呢？

&emsp;&emsp;很显然，Bigram 类的创建者原本想要覆盖 equals 方法（第 10 项），同时还记得覆盖了 hashCode。遗憾的是，不幸的程序猿没能覆盖 equals，而是将它重载了（第 52 项）。为了覆盖 Object.equals，必须定义一个参数为 Object 类型的 equals 方法，但是 Bigram 的 equals 方法的参数并不是 Object 类型，因此 Bigram 从 Object 继承了 equals 方法。这个 equals 方法测试对象的同一性，就像==操作符一样。每个 bigram 的 10 个备份中，每一个都与其余的 9 个不同，因此 Object.equals 认为它们不相等，这正解释了程序为什么会打印出 260 的原因。

&emsp;&emsp;幸运的是，编译器可以帮助你发现这个错误，但是只有当你告知编译器你想要覆盖 Object.equals 时才行。为了做到这一点，要用@Override 标注 Bigram.equals，如下所示：

```java
@Override
public boolean equals(Bigram b) {
    return b.first == first && b.second == second;
}
```

&emsp;&emsp;如果插入这个注解，并试着重新编译程序，编译器就会产生一条像这样的错误信息：

```java
Bigram.java:10: method does not override or implement a method
from a supertype
    @Override public boolean equals(Bigram b) {
    ^
```

&emsp;&emsp;你就会立即意识到哪里错了，拍拍自己的额头，马上用正确的来取代出错的 equals 实现（第 10 项）：

```java
@Override public boolean equals(Object o) {
    if (!(o instanceof Bigram))
        return false;
    Bigram b = (Bigram) o;
    return b.first == first && b.second == second;
}
```

&emsp;&emsp;因此，**你应该在你想要覆盖超类声明的每个方法声明中使用 Override 注解**。这一规则有个小小的例外。如果你在编写一个没有标注为抽象的类，并且确信它覆盖了抽象的方法，在这种情况下，就不必将 Override 注解放在该方法上了。在没有声明为抽象的类中，如果没有覆盖抽象的超类方法，编译器就会发出一条错误消息。但是，你可能希望关注类中所有覆盖超类方法的方法，在这种情况下，也可以放心地标注这些方法。当你选择覆盖方法时，大多数 IDE 可以设置为自动插入覆盖注释。

&emsp;&emsp;大多数 IDE 提供了坚持使用 Override 注解的另一种理由。如果启用相应的代码检验功能，当你的方法没有 Override 注解，却覆盖了超类方法时，IDE 就会产生一条警告。如果坚持使用 Override 注解，这些警告就会提醒你警惕无意识的覆盖。这些警告补充了编译器的错误信息，提醒你警惕无意识的覆盖失败。在 IDE 和编译器之间，可以确保你覆盖任何你想要覆盖的方法，无一遗漏。

&emsp;&emsp;Override 注解可以用在覆盖接口和类的声明的方法的声明上【Override 注解可以用在某些方法的声明上，这些方法是覆盖接口中声明的方法或者类中声明的方法】。随着默认方法的出现【接口中可以使用 default 修饰方法，提供接口中方法的默认实现】，更好的做法是在接口方法的具体实现上使用 Override 来确保签名是正确的。如果你知道接口没有默认方法，则可以选择在接口方法的具体声明上省略 Override 注解来减少混乱【保持代码的整洁性】。

&emsp;&emsp;但是在抽象类或者接口中，还是值得标注所有你想要的方法来覆盖超类或者超接口方法，无论是具体的还是抽象的。例如，Set 接口没有给 Collection 添加新方法，因此它应该在它的所有方法声明中包含 Override 注解，以确保它不会意外地给 Colection 接口添加任何新方法。

&emsp;&emsp;总而言之，如果在你想要的每个方法声明中使用 Override 注解来覆盖超类声明，编译器就可以替你防止出现大量的错误，但有一个例外。在具体的类中，不必标注你确信覆盖了抽象方法声明的方法（虽然这么做也没什么坏处）。

## 用标记接口定义接口类型

&emsp;&emsp;_标记接口（marker interface）_ 是没有包含方法声明的接口，而只是指明（或者“标明”）一个类实现了具有某种属性的接口。例如，考虑 Serilizable 接口（第 12 章）。通过实现这个接口，表明类的实例可以被写到 ObjectOutputStream（或者“被序列化”）。

&emsp;&emsp;你可能听说过标记注解（第 39 项）使得标记接口过时了。这种断言是不准确的。标记接口有两点胜过标记注解。首先，也是最重要的一点，**标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型**。标记接口类型的存在允许你在编译时捕获错误，如果使用标记注释，则只能在运行时才能捕获这些错误。

&emsp;&emsp;Java 的序列化工具（第 6 章）使用 Serializable 标记接口来指明类型是可序列化的。ObjectOutputStream.writeObject 方法（序列化传递给它的对象）要求其参数可序列化。如果此方法的参数是 Serializable 类型，使用了不合适的对象尝试序列化，则在编译时（通过类型检查）就能检测出来。编译时错误检测是标记接口的目的，但不幸的是，ObjectOutputStream.write API 没有利用 Serializable 接口：它的参数被声明为 Object 类型，因此尝试序列化不可序列化的对象时只有到运行时才会失败。

&emsp;&emsp;**标记接口胜过标记注解的另一个优点时，它们可以被更加精确地进行锁定**。如果注解类型利用 ElementType.TYPE 声明，它就可以被应用到任何类或者接口。假设有一个标记只适用于特殊接口的实现。如果将它定义成一个标记接口，就可以用它唯一的接口扩展成它使用的接口，从而保证所有标记类型也是使用的唯一接口的子类型。

&emsp;&emsp;可以说，Set 接口就是这样一个受限制的标记接口。它仅适用于 Collection 子类型，但它不会添加除 Collection 定义的方法之外的任何方法。它通常不被认为是标记接口，因为它改进了几个 Collection 方法的约定，包括 add，equals 和 hashCode。但是很容易想象只适用于某种特殊接口的子类型的标记接口，它没有改进接口的任何方法的约定。这种标记接口可以描述整个对象的某个约束条件，或者表明实例能够利用其他某个类的方法进行处理（就像 Serializable 接口表明实例可以通过 ObjectOutputStream 进行处理一样）。

&emsp;&emsp;标记注解优于标记接口的最大优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。

&emsp;&emsp;那么什么时候应该使用标记注解，什么时候应该使用标记接口呢？很显然，如果标记是应用到任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或扩展接口。如果标记只应用给类和接口，就要问问自己：我要编写一个还是多个只接受有这种标记的方法呢？如果是这种情况，就应该优先使用标记接口而非注解。这样你就可以用接口作为相关方法的参数类型，它真正可以为你提供编译时进行类型检查的好处。如果你可以说服自己，永远不想写一个只接受带有标记的对象的方法，那么你最好使用标记注解。此外，如果标记是大量使用注释的框架的一部分，那么标记注解是明确的选择。

&emsp;&emsp;总而言之，标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，考虑到未来可能要给标记添加更多的信息，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。**如果你发现自己在编写的是目标为 ElementType.TYPE 的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否会更加合适呢**。

&emsp;&emsp;从某种意义上说，本项与 22 项中“如果不想定义类型就不要使用接口”的说法相反。本项最接近的意思是说：如果想要定义类型，一定要使用接口。


## Lambda 优先于匿名类

&emsp;&emsp;在之前的做法中（Historically），使用单个抽象方法的接口（或很少的抽象类【只有一个抽象方法的抽象类数量比较少】）被用作函数类型。它们的实例称为函数对象，代表一个函数或一种行为。自 JDK 1.1 于 1997 年发布以来，创建函数对象的主要方法是匿名类（第 24 项）。下面的这个代码片段，用于按长度顺序对字符串列表进行排序，使用匿名类创建排序的比较函数（强制排序顺序）：

```java
// Anonymous class instance as a function object - obsolete!
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

&emsp;&emsp;匿名类适用于需要经典功能的面向对象的设计模式，特别是策略模式\[Gamma95\]。Comparator 接口表示用于排序的抽象策略; 上面的匿名类是排序字符串的具体策略。然而，匿名类的冗长使得 Java 中的函数式编程成为一个没有吸引力的前景。

&emsp;&emsp;在 Java 8 中，该语言正式成为这样一种概念，即使用单一抽象方法的接口是特殊的，值得特别对待。这些接口现在称为功能接口，该语言允许你使用 lambda 表达式或简称 lambdas 创建这些接口的实例。Lambdas 在功能上与匿名类相似，但更加简洁。以下是上面的代码片段如何将匿名类替换为 lambda。样板消失了，行为很明显：

```java
// Lambda expression as function object (replaces anonymous class)
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

&emsp;&emsp;请注意，lambda（Comparator <String>）的类型，其参数（s1 和 s2，两个 String）及其返回值（int）的类型不在代码中。编译器使用称为类型推断的过程从上下文中推导出这些类型。在某些情况下，编译器将无法确定类型，你必须指定它们。类型推断的规则很复杂：它们占据了 JLS 的整个章节\[JLS，18\]。很少有程序员详细了解这些规则，但这没关系。**省略所有 lambda 参数的类型，除非它们的存在使您的程序更清晰。** 如果编译器生成错误，告诉你无法推断 lambda 参数的类型，请指定它。有时你可能必须转换返回值或整个 lambda 表达式，但这种情况很少见。

&emsp;&emsp;关于类型推断，应该添加一个警告。第 26 项告诉你不要使用原始类型，第 29 项告诉你支持泛型类型，第 30 项告诉你支持泛型方法。当你使用 lambdas 时，这个建议是非常重要的，因为编译器获得了从泛型的执行类型推断出的大多数类型信息。如果你不提供此信息，编译器将无法进行类型推断，你必须在 lambdas 中手动指定类型，这将大大增加它们的详细程度【也就是代码量】。举例来说，如果变量词被声明为原始类型 List 而不是参数化类型 List <String>，那么上面的代码片段将无法编译。

&emsp;&emsp;顺便提一下，如果使用比较器构造方法代替 lambda，则片段中的比较器可以更简洁（第 14. 43 项）：

```java
Collections.sort(words, comparingInt(String::length));
```

&emsp;&emsp;实际上，通过利用 Java 8 中添加到 List 接口的 sort 方法，可以使代码段更短：

```java
words.sort(comparingInt(String::length));
```

&emsp;&emsp;将 lambda 添加到语言中使得使用函数对象变得切实可行。例如，请考虑第 34 项中的 Operation 枚举类型。因为每个枚举对其 apply 方法需要不同的行为，所以我们使用特定于常量的类主体并覆盖每个枚举常量中的 apply 方法。为了让你有清晰的记忆，这里是代码：

```java
// Enum type with constant-specific class bodies & data (Item 34)
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) { return x / y; }
    };
    private final String symbol;
    Operation(String symbol) { this.symbol = symbol; }
    @Override
    public String toString() { return symbol; }
    public abstract double apply(double x, double y);
}
```

&emsp;&emsp;第 34 项说 enum 实例字段比特定于常量的类体更可取。使用前者而不是后者，Lambdas 可以轻松实现特定于常量的行为。只需将实现每个枚举常量行为的 lambda 传递给它的构造函数。构造函数将 lambda 存储在实例字段中，apply 方法将调用转发给 lambda。生成的代码比原始版本更简单，更清晰：

```java
// Enum with function object fields & constant-specific behavior
public enum Operation {
    PLUS ("+", (x, y) -> x + y),
    MINUS ("-", (x, y) -> x - y),
    TIMES ("*", (x, y) -> x * y),
    DIVIDE("/", (x, y) -> x / y);
    private final String symbol;
    private final DoubleBinaryOperator op;

    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }

    @Override
    public String toString() { return symbol; }

    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }
}
```

&emsp;&emsp;请注意，我们使用 DoubleBinaryOperator 接口来表示枚举常量行为的 lambdas。这是 java.util.function（第 44 项）中许多预定义的功能接口之一。它表示一个函数，它接受两个 double 参数并返回一个 double 结果。

&emsp;&emsp;查看基于 lambda 的 Operation 枚举，您可能会认为特定于常量的方法体已经过时了，但事实并非如此。跟类和方法不一样，**lambdas 缺乏名称和文档; 如果一个运算过程不能自我解释【代码就是最好的文档】，或超过几行，请不要将它放在 lambda 中**。一行【代码】对于 lambda 是理想的，三行【代码】是合理的最大值。如果违反此规则，可能会严重损害程序的可读性。如果 lambda 很长或难以阅读，要么找到简化它的方法，要么重构你的程序来取代 lambda。此外，传递给枚举构造函数的参数在静态上下文中进行运算。因此，枚举构造函数中的 lambdas 无法访问枚举的实例成员。如果枚举类型具有难以理解的特定于常量的行为，无法在几行【代码】中实现，或者需要访问实例字段或方法，则仍然可以使用特定于常量的类主体。

&emsp;&emsp;同样，你可能会认为匿名类在 lambdas 时代已经过时了。这很接近事实，但是你可以用匿名类做一些你无法用 lambdas 做的事情。Lambdas 仅限于函数接口。如果要创建抽象类的实例，可以使用匿名类，但不能使用 lambda。同样，你可以使用匿名类来创建具有多个抽象方法的接口实例。最后，lambda 无法获得对自身的引用。在 lambda 中，this 关键字引用封闭的实例，这通常是你想要的。在匿名类中，this 关键字引用匿名类实例。如果需要从其体内【类内部】访问函数对象，则必须使用匿名类。【在 lambda 表达式中使用 this 关键字，获得的引用是 lambda 所在的实例的引用，在匿名类中使用 this 关键字，获得的是当前匿名类的实例的引用】

&emsp;&emsp;Lambdas 与匿名类都具有无法在实现中可靠地序列化和反序列化它们的属性【lambda 和匿名类都无法被序列化和反序列化】。因此，你应该很少（如果有的话）序列化 lambda（或匿名类实例）。如果您有一个要进行序列化的函数对象，例如 Comparator，请使用私有静态嵌套类的实例（第 24 项）。

&emsp;&emsp;总之，从 Java 8 开始，lambda 是迄今为止表示小函数对象的最佳方式。**除非必须创建非功能接口类型的实例，否则不要对函数对象使用匿名类**。另外，请记住，lambda 使得通过使用对象来代表小函数变得如此容易，以至于它打开了以前在 Java 中不实用的函数式编程技术的大门。

## 方法引用优先于 Lambda

&emsp;&emsp;lambda 优于匿名类的主要优点是它们更简洁。Java 提供了一种生成函数对象的方法，它比 lambda 更简洁：方法引用。这是一个程序的代码片段，它维护从任意 key 到 Integer 值的映射。如果该值被解释为 key 实例数的计数，则该程序是多集实现。代码段的功能是将数字 1 与 key 相关联（如果它不在映射中），并在 key 已存在时增加相关值：

```java
map.merge(key, 1, (count, incr) -> count + incr);
```

&emsp;&emsp;请注意，此代码使用 merge 方法，该方法已添加到 Java 8 中的 Map 接口。如果给定键 key 没有映射，则该方法只是插入给定的值; 如果已存在映射，则 merge 将给定的函数应用于当前值和给定值，并使用结果覆盖当前值。这段代码表示 merge 方法的典型用例。

&emsp;&emsp;代码读起来很 nice，但仍然有一些样板【代码】。参数 count 和 incr 不会增加太多值，并且占用相当大的空间。实际上，所有 lambda 告诉你的是该函数返回其两个参数的总和。从 Java 8 开始，Integer（以及所有其他包装的数字基本类型）提供了一个完全相同的静态方法 sum。我们可以简单地传递对此方法的引用，获得相同的结果，并且【代码】看起来不会那么乱：

```java
map.merge(key, 1, Integer::sum);
```

&emsp;&emsp;方法具有的参数越多，使用方法引用可以消除的样板【代码】就越多。但是，在某些 lambda 中，你选择的参数名称提供了有用的文档，使得 lambda 比方法引用更易读和可维护，即使 lambda 更长。

&emsp;&emsp;对于一个你不能用 lambda 做的方法引用，你无能为力（有一个模糊的例外 - 如果你很好奇，请参阅 JLS，9.9-2）。也就是说，方法引用通常会导致更短，更清晰的代码。如果 lambda 变得太长或太复杂，它们也会给你一个方向（out）：你可以将 lambda 中的代码提取到一个新方法中，并用对该方法的引用替换 lambda。你可以为该方法提供一个好名称，并将其记录在核心的内容中。

&emsp;&emsp;如果你使用 IDE 进行编程，如果可以的话，它就会提供方法引用替换 lambda。你要经常（并不总是）接受 IDE 提供的建议。有时候，lambda 将比方法引用更简洁。当方法与 lambda 属于同一类时，这种情况最常发生。例如，考虑这个片段，假定它出现在名为 GoshThisClassNameIsHumongous 的类中：

```java
service.execute(GoshThisClassNameIsHumongous::action);
```

&emsp;&emsp;使用 lambda 看起来像这样：

```java
service.execute(() -> action());
```

&emsp;&emsp;使用方法引用的代码段既不比使用 lambda 的代码段更短也更清晰，所以更喜欢后者。类似地，Function 接口提供了一个通用的静态工厂方法来返回 Identity 函数 Function.identity()。它通常更短更清洁，不使用此方法，而是编写等效的 lambda 内联：x -> x。

&emsp;&emsp;许多方法引用会引用静态方法，但有四种方法引用不会引用静态方法。其中两个是绑定和未绑定的实例方法引用。在绑定引用中，接收对象在方法引用中指定。绑定引用在本质上类似于静态引用：函数对象采用与引用方法相同的参数。在未绑定的引用中，在应用函数对象时，通过方法声明的参数之前的附加参数指定接收对象。未绑定引用通常用作流管道（stream pipelines）（第 45 项）中的映射和过滤功能。最后，对于类和数组，有两种构造函数引用。构造函数引用充当工厂对象。所有五种方法参考总结在下表中：

| Method Ref Type   | Example             | Lambda Equivalent                                      |
| ----------------- | ------------------- | ------------------------------------------------------ |
| Static            | Integer::parseInt   | str -> Integer.parseInt(str)                           |
| Bound             | Integer::parseIntr  | Instant then = Instant.now();<br> t -> then.isAfter(t) |
| Unbound           | String::toLowerCase | str -> str.toLowerCase()                               |
| Class Constructor | TreeMap<K, V>::new  | () -> new TreeMap<K, V>                                |
| Array Constructor | int[]::new          | len -> new int\[len\]                                  |

&emsp;&emsp;总之，方法引用通常提供一种更简洁的 lambda 替代方案。**在使用方法引用可以更简短更清晰的地方，就使用方法引用，如果无法使代码更简短更清晰的地方就坚持使用 lambda。（Where method references are shorter and clearer, use them; where they aren’t, stick with lambdas.）**


## 谨慎使用 Stream

&emsp;&emsp;在 Java 8 中添加了 Stream API，以简化串行或并行批量执行操作的任务。这个 API 提供了两个关键的抽象概念：*流（stream）*表示有限或无限的数据元素序列，*流管道（stream pipeline）*表示对这些元素的多级计算。流中的元素可以来自任何地方。常见的来源包括集合，数组，文件，正则表达式模式匹配器，伪随机数生成器和其他流。流中的数据元素可以是对象的引用或基本类型。支持三种基本类型：int，long 和 double。

&emsp;&emsp;流管道由源流和零个或多个*中间操作（intermediate operations ）*以及一个*终端操作（ terminal operation）*组成。每个中间操作以某种方式转换流，例如将每个元素映射到该元素的函数或过滤掉不满足某些条件的所有元素。中间操作都将一个流转换为另一个流，其元素类型可以与输入流相同或与之不同。终端操作对从最后的中间操作产生的流执行最终计算，例如将其元素存储到集合中，返回某个元素或打印其所有元素。

&emsp;&emsp;流管道是懒求值（evaluated lazily）：在调用终端操作之前是不会开始求值的，并且不会去计算那些在完成终端操作的过程中不需要的数据元素。这种懒求值使得可以使用无限流。请注意，没有终端操作的流管道是静默无操作的，因此不要忘记包含一个【终端操作】（Stream pipelines are evaluated lazily: evaluation doesn’t start until the terminal operation is invoked, and data elements that aren’t required in order to complete the terminal operation are never computed. This lazy evaluation is what makes it possible to work with infinite streams. Note that a stream pipeline without a terminal operation is a silent no-op, so don’t forget to include one. ）。

&emsp;&emsp;流 API 非常流畅：它旨在允许将构成管道的所有调用链接（chain）到单个表达式中。实际上，多个管道可以链接（chain）在一起形成一个表达式。

&emsp;&emsp;默认情况下，流管道按顺序运行。使管道并行执行就像在管道中的任何流上调用并行方法一样简单，但很少这样做（第 48 项）。

&emsp;&emsp;流 API 具有足够的通用性（The streams API is sufficiently versatile），几乎任何计算都可以使用流来执行，但仅仅因为你可以这么做并不意味着你应该这样做。如果使用得当，流可以使程序更短更清晰; 如果使用不当，可能会使程序难以阅读和维护。

&emsp;&emsp;考虑以下程序，该程序从字典文件中读取单词并打印其大小符合用户指定的最小值的所有相同字母异序词组（anagram groups）。回想一下，如果两个单词由不同顺序的相同字母组成，则它们是相同字母异序词。程序从用户指定的字典文件中读取每个单词并将单词放入 map 中。map 的键是用字母按字母顺序排列的单词，因此“staple”的键是“aelpst”，“petals”的键也是“aelpst”：两个单词是相同字母异序词，所有的相同字母异序词共享相同的字母形式（或 alphagram，因为它有时是已知的（(or alphagram, as it is sometimes known））。map 的值是包含按字母顺序排列的共享形式的所有单词的列表。字典处理完毕后，每个列表都是一个完整的相同字母异序词组。然后程序遍历 map 的 values（）并打印每个大小符合阈值的列表：

```java
// Prints all large anagram groups in a dictionary iteratively
public class Anagrams {
    public static void main(String[] args) throws IOException {
        File dictionary = new File(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);
        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();
                groups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word);
            }
        }
        for (Set<String> group : groups.values())
            if (group.size() >= minGroupSize)
                System.out.println(group.size() + ": " + group);
    }

    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

&emsp;&emsp;该计划的一个步骤值得注意。将每个单词插入到 map 中（以粗体显示的：groups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word);）使用了在 Java 8 中添加的 computeIfAbsent 方法。此方法在 map 中查找键：如果键存在，则该方法仅返回与其关联的值。如果不是，则该方法通过将给定的函数对象应用于键来计算值，将该值与键相关联，并返回计算的值。computeIfAbsent 方法简化了将多个值与每个键相关联的映射的实现。

&emsp;&emsp;现在考虑以下程序，它解决了同样的问题，但大量使用了流。请注意，除了打开字典文件的代码之外，整个程序都包含在一个表达式中。在单独的表达式中打开字典的唯一原因是允许使用 try-with-resources 语句，以确保字典文件已关闭：

```java
// Overuse of streams - don't do this!
public class Anagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);
        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                groupingBy(word -> word.chars().sorted()
                    .collect(StringBuilder::new,
                    (sb, c) -> sb.append((char) c),
                    StringBuilder::append).toString()))
            .values().stream()
            .filter(group -> group.size() >= minGroupSize)
            .map(group -> group.size() + ": " + group)
            .forEach(System.out::println);
        }
    }
}
```

&emsp;&emsp;如果你发现此代码难以阅读，请不要担心; 你不是一个人。它更短，但可读性更小，特别是对于不是使用流的专家级程序猿。**过度使用流会使程序难以阅读和维护**。

&emsp;&emsp;幸运的是，有一个让人开心的工具。以下程序使用流而不会过度使用流来解决相同的问题。结果是一个比原始程序更短更清晰的程序：

```java
// Tasteful use of streams enhances clarity and conciseness
public class Anagrams {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get(args[0]);
        int minGroupSize = Integer.parseInt(args[1]);
        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(groupingBy(word -> alphabetize(word)))
                .values().stream()
                .filter(group -> group.size() >= minGroupSize)
                .forEach(g -> System.out.println(g.size() + ": " + g));
        }
    }
    // alphabetize method is the same as in original version
}
```

&emsp;&emsp;即使你以前很少接触过流，这个程序也不难理解。它在 try-with-resources 块中打开字典文件，获取包含文件中所有行的流。stream 变量被命名为 words，表示流中的每个元素都是一个 word。此流上的管道没有中间操作; 它的终端操作将所有 word 收集到一个 map 中，该 map 按字母顺序排列单词（第 46 项）。这与在以前版本的程序中构建的 map 完全相同。然后在 map 的 values（）中打开一个新的 Stream<List<String>>。当然，这个流中的元素是相同字母异序词组。过滤流以便忽略大小小于 minGroupSize 的所有组，最后，通过终端操作 forEach 打印剩余的组。

&emsp;&emsp;请注意，小心选择了 lambda 参数名称。参数 g 应该真正命名为 group，但是生成的代码行对于本书来说太宽了。**在没有显式类型的情况下，仔细命名 lambda 参数对于流管道的可读性至关重要**。

&emsp;&emsp;另外请注意，单词字母化是在单独的 alphabetize 方法中完成的。这通过提供操作的名称并将实现细节保留在主程序之外来增强可读性。**使用辅助方法对于流管道中的可读性比在迭代代码中更为重要**，因为管道缺少显式类型信息和命名临时变量。

&emsp;&emsp;可以使用流重新实现 alphabetize 方法，但是基于流的 alphabetize 方法不太清晰，更难以正确编写，并且可能更慢。这些缺陷是由于 Java 缺乏对原始 char 流的支持（这并不意味着 Java 应该支持 char 流；这样做是不可行的）。要演示使用流处理 char 值的危险，请考虑以下代码：

```java
"Hello world!".chars().forEach(System.out::print);
```

&emsp;&emsp;你可能希望它打印 Hello world！，但如果你运行它，你会发现它打印 721011081081113211911111410810033。这是因为“Hello world！”.chars（）返回的流的元素不是 char 值而是 int 值，因此调用的是 print 的 int 重载【方法】。令人遗憾的是，名为 chars 的方法返回一个 int 值流。你可以通过使用强制转换来强制调用正确的重载来修复程序：

```java
"Hello world!".chars().forEach(x -> System.out.print((char) x));
```

&emsp;&emsp;但理想情况下，你应该**避免使用流来处理 char 值**。

&emsp;&emsp;当你开始使用流时，你可能会有将所有循环转换为流的冲动的感觉，但要抵制这种冲动。尽管这只是有可能发生，但它会损害代码库的可读性和可维护性。通常，使用流和遍历的某种组合可以最好地完成中等复杂程度的任务，如上面的 Anagrams 程序所示。因此，**重构现有代码以使用流，并仅在有意义的情况下在新代码中使用它们**。

&emsp;&emsp;如该项目中的程序所示，流管道使用函数对象（通常是 lambdas 或方法引用）表示重复计算，而遍历代码使用代码块表示重复计算。以下操作你可以在代码块中执行，但无法在函数对象中执行：

- 在代码块中，你可以读取或修改范围内的任何局部变量; 在 lambda 中，你只能读取最终或有效的最终变量[JLS 4.12.4]，并且你无法修改任何局部变量。

- 在代码块中，不可以从封闭方法返回，中断或继续封闭循环，或抛出声明此方法被抛出的任何已受检异常; 在一个 lambda 你无法做到这些事情。

&emsp;&emsp;如果使用这些技巧可以更好地表达计算【过程】，那么流就可能不是最好的方式（If a computation is best expressed using these techniques, then it’s probably not a good match for streams）。相反，流可以很容易做一些事情：

- 均匀地转换元素序列
- 过滤元素序列
- 使用单个操作组合元素序列（例如，添加它们，串联（concatenate ）它们或计算它们的最小值）
- 将元素序列累积（accumulate）到集合中，或者通过一些常见属性对它们进行分组
- 在元素序列中搜索满足某个条件的元素

&emsp;&emsp;如果使用这些技巧可以更好地表达计算【过程】，那么流是它的良好候选者。

&emsp;&emsp;使用流很难做的一件事是同时从管道的多个阶段访问相应的元素：一旦将值映射到某个其他值，原始值就会丢失。一种解决方法是将每个值映射到包含原始值和新值的*对对象（pair object）*，但这不是一个令人满意的解决方案，尤其是如果管道的多个阶段需要对对象。由此产生的代码是混乱和冗长的，这破坏了流的主要目的。如果适当使用的话，更好的解决方法是在需要访问早期阶段值的时候反转映射。（When it is applicable, a better workaround is to invert the mapping when you need access to the earlier-stage value）。

&emsp;&emsp;例如，让我们编写一个程序来打印前 20 个*梅森素数(Mersenne primes)*。为了更新你的记忆，梅森数是一个 2^p-1 的数字。如果 p 是素数，相应的梅森数可能是素数; 如果是这样的话，那就是梅森素数。作为我们管道中的初始流，我们需要所有素数。这是一种返回该（无限）流的方法。我们假设使用静态导入来轻松访问 BigInteger 的静态成员：

```java
static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

&emsp;&emsp;方法（primes）的名称是描述流的元素的复数名词。强烈建议所有返回流的方法使用此命名约定，因为它增强了流管道的可读性。该方法使用静态工厂 Stream.iterate，它接受两个参数：流中的第一个元素，以及从前一个元素生成流中的下一个元素的函数。这是打印前 20 个梅森素数的程序:

```java
public static void main(String[] args) {
    primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(System.out::println);
}
```

&emsp;&emsp;这个程序是上文描述中的直接编码：它从素数开始，计算相应的梅森数，过滤掉除素数之外的所有数字（幻数 50 控制概率素性测试（the magic number 50 controls the probabilistic primality tes）），将得到的流限制为 20 个元素，并打印出来。

&emsp;&emsp;现在假设我们想要在每个梅森素数之前加上它的指数（p）。该值仅出现在初始流中，因此在终端操作中无法访问，从而打印结果。幸运的是，通过反转第一个中间操作中发生的映射，可以很容易地计算出梅森数的指数。指数只是二进制表示中的位数，因此该终端操作生成所需的结果：

```java
.forEach(mp -> System.out.println(mp.bitLength() + ": " + mp));
```

&emsp;&emsp;有很多任务，无论是使用流还是迭代都不明显。例如，考虑初始化一副新牌的任务。假设 Card 是一个值不可变的类，它封装了 Rank 和 Suit，两者都是枚举类型。此任务代表任何需要的计算可以从两组中选择所有元素对的任务。数学家称之为两组的*笛卡尔积（Cartesian product ）*。这是一个带有嵌套 for-each 循环的迭代实现，对你来说应该很熟悉：

```java
// Iterative Cartesian product computation
private static List<Card> newDeck() {
    List<Card> result = new ArrayList<>();
    for (Suit suit : Suit.values())
        for (Rank rank : Rank.values())
            result.add(new Card(suit, rank));
    return result;
}
```

&emsp;&emsp;这是一个基于流的实现，它使用了中间操作 flatMap。此操作将流中的每个元素映射到流，然后将所有这些新流连接成单个流（或展平它们(or flattens them)）。请注意，此实现包含嵌套的 lambda，以粗体显示；

```java
// Stream-based Cartesian product computation
private static List<Card> newDeck() {
    return Stream.of(Suit.values())
        .flatMap(suit ->
            Stream.of(Rank.values())
                .map(rank -> new Card(suit, rank)))
        .collect(toList());
}
```

&emsp;&emsp;newDeck 的两个版本中哪一个更好？它归结为个人偏好和你的编程环境。第一个版本更简单，也许感觉更自然。大部分 Java 程序猿将能够理解和维护它，但是一些程序猿会对第二个（基于流的）版本感觉更舒服。如果你对流和函数式编程很精通，那么它会更简洁，也不会太难理解。如果你不确定自己喜欢哪个版本，则迭代版本可能是更安全的选择。如果你更喜欢流版本，并且你相信其他使用该代码的程序猿跟你有共同的偏好，那么你应该使用它。

&emsp;&emsp;总之，一些任务最好用流完成，其他任务最好用遍历完成。通过组合这两种方法可以最好地完成许多任务。选择哪种方法用于任务没有硬性规定，但有一些有用的启发式方法。在许多情况下，将清楚使用哪种方法; 在某些情况下，它不会。**如果你不确定某个任务是否更适合流或遍历，那么就两个都尝试一下，并看一下哪个更好**。

## Stream 要优先用 Collection 作为返回类型

&emsp;&emsp;许多方法返回元素序列。在 Java 8 之前，这些方法的返回类型是集合的接口 Collection，Set 和 List;Iterable;和数组类型。通常，很容易决定返回哪些类型。准确来说是一个集合接口。如果该方法仅用于 for-each 循环或返回的序列无法实现某些 Collection 方法（通常为 contains(Object)），则使用 Iterable 接口。如果返回的元素是基本类型值或者存在严格的性能要求，则使用数组。在 Java 8 中，流被添加到 java 库中，这使得为返回序列的方法选择恰当的返回类型的任务变得非常复杂。

&emsp;&emsp;你可能听说过，流现在是返回一系列元素的公认选择，正如第 45 项所描述的，流不会使迭代过时：编写好的代码需要适当地组合流和遍历。如果 API 只返回一个流，而某些用户想要使用 for-each 循环遍历返回的序列，那么这些用户理所当然会感到不安。特别令人沮丧的是，Stream 接口包含 Iterable 接口中唯一的抽象方法，Stream 的此方法规范与 Iterable 兼容。

&emsp;&emsp;可悲的是，这个问题没有好的解决方法。乍一看，似乎可以将方法引用传递给 Stream 的迭代器方法。结果代码可能有点嘈杂和模糊，但并非不合理：

```java
// Won't compile, due to limitations on Java's type inference
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
    // Process the process
}
```

&emsp;&emsp;不幸的是，如果你尝试编译此代码，你将收到一条错误消息：

```java
Test.java:6: error: method reference not expected here
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
                        ^
```

&emsp;&emsp;为了使代码编译，你必须将方法引用强制转换为适合参数化的 Iterable：

```java
// Hideous workaround to iterate over a stream
for (ProcessHandle ph : (Iterable<ProcessHandle>) ProcessHandle.allProcesses()::iterator)
```

&emsp;&emsp;此客户端代码有效，但在实践中使用它太嘈杂和模糊。更好的解决方法是使用适配器方法。JDK 没有提供这样的方法，但是使用上面的代码片段中相同的技术，可以很容易地编写一个方法。请注意，在适配器方法中不需要强制转换，因为 Java 类型推断在此上下文中正常工作：

```java
// Adapter from Stream<E> to Iterable<E>
public static <E> Iterable<E> iterableOf(Stream<E> stream) {
    return stream::iterator;
}
```

&emsp;&emsp;使用此适配器，你可以使用 for-each 语句迭代任何流：

```java
for (ProcessHandle p : iterableOf(ProcessHandle.allProcesses())) {
    // Process the process
}
```

&emsp;&emsp;请注意，第 34 项中的 Anagrams 程序的流版本使用 Files.lines 方法读取字典，而迭代版本使用 scanner。Files.lines 方法优于 scanner，它可以在读取文件时悄悄地处理（silently swallows）任何异常。理想情况下，我们也会在迭代版本中使用 Files.lines。如果 API 仅提供对序列的流的访问并且他们希望使用 for-each 语句遍历序列，那么程序员将会做出这种折中的方法【在迭代的版本中使用 Files.lines】。

&emsp;&emsp;相反，想要使用流管道处理序列的程序猿理所当然会因为 API 仅提供 Iterable 而感到难过【傲娇】。再提一次 JDK 没有提供适配器，但编写一个是很容易的：

```java
// Adapter from Iterable<E> to Stream<E>
public static <E> Stream<E> streamOf(Iterable<E> iterable) {
    return StreamSupport.stream(iterable.spliterator(), false);
}
```

&emsp;&emsp;如果你正在编写一个返回一系列对象的方法，并且你知道它只会在流管道中使用，那么你当然可以随意返回一个流。类似地，返回仅用于遍历的序列的方法应返回 Iterable。但是，如果你正在编写一个返回序列的公共 API，那么你应该为想要编写流管道的用户以及想要编写 for-each 语句的用户提供服务。除非你有充分的理由相信【使用该 API 的】大多数用户希望使用相同的机制。

&emsp;&emsp;Collection 接口是 Iterable 的子类型，并且具有 stream 方法，因此它提供迭代和流访问。因此，**Collection 或适当的子类型通常是公共序列返回方法的最佳返回类型**。 Arrays 还提供了 Arrays.asList 和 Stream.of 方法的简单遍历和流访问。如果你返回的序列小到足以容易地放入内存中，那么最好返回一个标准的集合实现，例如 ArrayList 或 HashSet。但是**不要在内存中存储大的序列而只是为了将它作为集合返回。**

&emsp;&emsp;如果你返回的序列很大但可以简洁地表示，请考虑实现一个特殊用途的集合。例如，假设你要返回给定集的*幂集（power set）*，该集包含其所有子集。{a，b，c}的幂集为{{}，{a}，{b}，{c}，{a，b}，{a，c}，{b，c}，{a，b，c}}。如果一个集合具有 n 个元素，则其幂集具有 2^n 个。因此，你甚至不应该考虑将幂集存储在标准集合的实现中。但是，在 AbstractList 的帮助下，很容易为此实现自定义集合。

&emsp;&emsp;技巧是使用幂集中每个元素的索引作为位向量，其中索引中的第 n 位表示源集合中是否存在第 n 个元素。本质上，从 0 到 2^n - 1 的二进制数和 n 个元素集的幂集之间存在自然映射。以下是代码：

```java
// Returns the power set of an input set as custom collection
public class PowerSet {
    public static final <E> Collection<Set<E>> of(Set<E> s) {
        List<E> src = new ArrayList<>(s);
        if (src.size() > 30)
            throw new IllegalArgumentException("Set too big " + s);
        return new AbstractList<Set<E>>() {
            @Override public int size() {
                return 1 << src.size(); // 2 to the power srcSize
            }
            @Override public boolean contains(Object o) {
                return o instanceof Set && src.containsAll((Set)o);
            }
            @Override public Set<E> get(int index) {
            Set<E> result = new HashSet<>();
                for (int i = 0; index != 0; i++, index >>= 1)
                    if ((index & 1) == 1)
                        result.add(src.get(i));
                return result;
            }
        };
    }
}
```

&emsp;&emsp;请注意，如果输入集具有超过 30 个元素，则 PowerSet.of 会抛出异常。这突出了使用 Collection 作为返回类型的缺点(而 Stream 或 Iterable 没有该缺点）：Collection 具有 int 返回大小的方法，该方法将返回序列的长度，限制为 Integer.MAX_VALUE 或 2^31-1。如果集合更大，甚至无限，Collection 规范允许 size 方法返回 2^31-1，但这不是一个完全令人满意的解决方案。

&emsp;&emsp;为了在 AbstractCollection 上编写 Collection 实现，你只需要实现 Iterable 所需的两个方法：contains 和 size。通常，编写这些方法的有效实现是很容易的。如果不可行，可能是因为在迭代发生之前无法预先确定序列的内容，返回流或可迭代的【结果】，哪种感觉起来更自然就返回哪种。如果你要选择的话，你可以使用两种不同的方法将两种类型都返回。

&emsp;&emsp;有时你会根据实施方式的难易程度选择返回类型。例如，假设你要编写一个返回输入列表的所有（连续）子列表的方法。生成这些子列表只需要三行代码并将它们放在标准集合中，但保存此集合所需的内存是源列表大小的二次方。虽然这并不像指数级的幂集那么糟糕，但显然是不可接受的。正如我们为幂集所做的那样，实现自定义集合将是冗长的，因为 JDK 缺乏 Iterator 框架实现来帮助我们。

&emsp;&emsp;但是【我们可以】直接实现输入列表的所有子列表的流，尽管它确实需要一些洞察力。让我们调用一个子列表，该子列表包含列表的第一个元素和列表的*前缀（prefix）*。例如，（a，b，c）的前缀是（a），（a，b）和（a，b，c）。 类似地，让我们调用包含后缀的最后一个元素的子列表，因此（a，b，c）的后缀是（a，b，c），（b，c）和（c）。洞察的点就是列表的子列表只是前缀的后缀（或相同的后缀的前缀）和空列表。通过这个观点直接就可以有了清晰、合理简洁的实施方案：

```java
// Returns a stream of all the sublists of its input list
public class SubLists {
    public static <E> Stream<List<E>> of(List<E> list) {
        return Stream.concat(Stream.of(Collections.emptyList()), prefixes(list).flatMap(SubLists::suffixes));
    }
    private static <E> Stream<List<E>> prefixes(List<E> list) {
        return IntStream.rangeClosed(1, list.size()).mapToObj(end -> list.subList(0, end));
    }
    private static <E> Stream<List<E>> suffixes(List<E> list) {
        return IntStream.range(0, list.size()).mapToObj(start -> list.subList(start, list.size()));
    }
}
```

&emsp;&emsp;请注意，Stream.concat 方法用于将空列表添加到返回的流中。另请注意，flatMap 方法（第 45 项）用于生成由所有前缀的所有后缀组成的单个流。最后，请注意我们通过映射 IntStream.range 和 IntStream.rangeClosed 返回的连续 int 值的流来生成前缀和后缀。简单地说，这个习惯用法是整数索引上标准 for 循环的流等价物（ This idiom is, roughly speaking, the stream equivalent of the standard for-loop on integer indices）。因此，我们的子列表实现的思想类似明显的嵌套 for 循环：

```java
for (int start = 0; start < src.size(); start++)
    for (int end = start + 1; end <= src.size(); end++)
        System.out.println(src.subList(start, end));
```

&emsp;&emsp;可以将此 for 循环直接转换为流。结果比我们之前的实现更简洁，但可读性稍差。它的思想类似第 45 项中笛卡尔积的流代码：

```java
// Returns a stream of all the sublists of its input list
public static <E> Stream<List<E>> of(List<E> list) {
    return IntStream.range(0, list.size())
        .mapToObj(start -> IntStream.rangeClosed(start + 1, list.size())
        .mapToObj(end -> list.subList(start, end)))
        .flatMap(x -> x);
}
```

&emsp;&emsp;与之前的 for 循环一样，此代码不会产生（emit）空列表。为了解决这个问题，你可以使用 concat，就像我们在之前版本中所做的那样，或者在 rangeClosed 调用中用（int）Math.signum（start）替换 1。

&emsp;&emsp;这些子列表的流实现中的任何一个都很好，但两者都需要用户使用一些 Stream-to-Iterable 适配器或在迭代更自然的地方使用流。Stream-to-Iterable 适配器不仅使客户端代码混乱，而且还会使我的机器上的循环速度降低 2.3 倍。专用的 Collection 实现（此处未显示）相当冗长，但运行速度是我机器上基于流的实现的 1.4 倍。

&emsp;&emsp;总之，在编写返回元素序列的方法时，请记住，你的某些用户可能希望将它们作为流进行处理，而其他用户可能希望使用它们进行遍历。尽量适应这两个群体。如果返回集合是可行的，那么就返回集合。如果你已经拥有集合中的元素，或者序列中的元素数量很小足以证明创建新元素是正确的，那么就返回标准集合，例如 ArrayList。否则，请考虑实现自定义的集合，就像我们为幂集所做的那样。如果返回集合是不可行的，则返回一个流或可迭代的【类型】，无论哪个看起来更自然。如果在将来的 Java 版本中，Stream 接口声明被修改为扩展（extend）Iterable，那么你应该随意返回流，因为它们将允许进行流处理和遍历。

## 谨慎使用 Stream 并行

&emsp;&emsp;在主流语言中，在提供便于并发编程任务功能方面，Java 始终处于最前沿【的位置】（Among mainstream languages, Java has always been at the forefront of providing facilities to ease the task of concurrent programming）。当 Java 于 1996 年发布时，它内置了对线程的支持，具有同步和等待/通知【的功能】（When Java was released in 1996, it had built-in support for threads, with synchronization and wait/notify）。Java 5 引入了 java.util.concurrent 库，包含并发集合和执行器框架。 Java 7 引入了 fork-join 包，这是一个用于并行分解（parallel decomposition）的高性能框架。Java 8 引入了流，可以通过对并行方法的单个调用来并行化。用 Java 编写并发程序变得越来越容易，但编写正确快速的并发程序就跟以前一样困难。安全性和活性违规（liveness violations ）是并发编程中的事实，并行流管道也不例外。

&emsp;&emsp;考虑第 45 项中的这个程序：

```java
// Stream-based program to generate the first 20 Mersenne primes
public static void main(String[] args) {
    primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
        .filter(mersenne -> mersenne.isProbablePrime(50))
        .limit(20)
        .forEach(System.out::println);
}
static Stream<BigInteger> primes() {
    return Stream.iterate(TWO, BigInteger::nextProbablePrime);
}
```

&emsp;&emsp;在我的机器上，该程序立即开始打印质数，并需要 12.5 秒才能完成运行。假设我试图通过向流管道添加对 parallel()的调用来加速它。你认为它的表现会怎样？它【的运行速度】会加快几个百分点吗？还是慢几个百分点？可悲的是，发生的事情是它没有打印任何东西，但是 CPU 使用率飙升至 90％并且无限期地停留在那里（_活性失败(liveness failure)_）。该程序最终可能会终止，但我不愿意去发现【等待这个结果】; 半小时后我强行停止【了程序】。

&emsp;&emsp;这里发生了什么？简而言之，流的库不知道如何并行化此管道并且试探启动（heuristics）失败。即使在最好的情况下，**如果源来自 Stream.iterate，或者使用中间操作限制，并行化管道也不太可能提高其性能(parallelizing a pipeline is unlikely to increase its performance if the source is from Stream.iterate, or the intermediate operation limit is used.)**。这条管道必须应对这两个问题。更糟糕的是，默认的并行化策略是通过假设处理一些额外元素并丢弃任何不需要的结果不会带来任何损失的前提下来处理限制的不可预测性。在这种情况下，找到每个梅森质数需要大约两倍的时间才能找到前一个。因此，计算单个额外元素的成本大致等于计算所有先前元素组合的成本，并且这种看起来没什么损失的管道会使自动并行化算法瘫痪。这个故事的寓意很简单：**不要不加选择的地使用并行化流**。导致的性能后果可能是灾难性的。

&emsp;&emsp;**并行性的性能增益最好是在 ArrayList，HashMap，HashSet 和 ConcurrentHashMap 实例上；int 数组；和 long 数组(performance gains from parallelism are best on streams over ArrayList, HashMap, HashSet, and ConcurrentHashMap instances; arrays; int ranges; and long ranges)**，将这作为一项规则。这些数据结构的共同之处在于它们都可以准确且分成任何所需大小的子范围的代价是很小的，这使得在并行线程之间划分工作变得容易。流库用于执行此任务的抽象是 spliterator，它由 Stream 和 Iterable 上的 spliterator 方法返回。

&emsp;&emsp;所有这些数据结构的另一个重要因素是它们在顺序处理时提供了非常好的*位置引用(locality of reference)*：元素的顺序和【元素的】引用一起存储在存储器中。这些引用所引用的对象在存储器中可能彼此不接近，这减少了位置引用(The objects referred to by those references may not be close to one another in memory, which reduces locality-of-reference.)。对于并行化操作而言，位置引用非常重要：如果没有位置引用，线程大部分时间会处在空闲状态，等待数据从内存传输到处理器的缓存。具有最佳位置引用的数据结构是原始数组，因为数据本身连续存储在存储器中。

&emsp;&emsp;流管道终端操作的本质也会影响并行执行的有效性。如果与管道的整体工作相比在终端操作中完成了大量工作并且该操作本质上是按顺序的，那么并行化管道的有效性是受限的。并行性最佳的终端操作是*减少（reductions）*，其中从管道中出现的所有元素使用 Stream 的 reduce 方法或减少预打包(prepackaged reductions)（例如 min，max，count 和 sum）进行组合。*短路操作(shortcircuiting)*anyMatch，allMatch 和 noneMatch 也适用于并行操作。Stream 的 collect 方法执行的操作（称为*可变约简( mutable reductions)*）不是并行性的良好选择，因为组合集合的开销是很昂贵的。

&emsp;&emsp;如果你编写自己的 Stream，Iterable 或 Collection 实现并且希望获得良好的并行性能，则必须覆盖 spliterator 方法并广泛测试生成的流的并行性能。编写高质量的 spliterators 是很困难的，超出了本书的范围。

&emsp;&emsp;**并行化流不仅会导致性能不佳，包括活性失败; 它可能导致不正确的结果和不可预测的行为（安全性失败）**。使用映射器，过滤器和其他程序员提供的不符合其规范的功能对象的管道并行化可能会导致安全性失败。Stream 规范对这些功能对象提出了严格的要求。例如，传递给 Stream 的 reduce 操作的累加器和组合器函数必须是关联的，非侵入的和无状态的。如果你违反了这些要求（其中一些在第 46 项中讨论过），但按顺序运行你的管道，则可能会产生正确的结果; 如果你将它并行化，它可能会失败，也许是灾难性的。

&emsp;&emsp;沿着这些思路，值得注意的是，即使并行化的梅森素数程序已经完成，它也不会以正确的（升序）顺序打印素数。要保留顺序版本显示的顺序，你必须使用 forEachOrdered 替换 forEach 终端操作，该操作保证以*相遇顺序(encounter order)*遍历并行流。

&emsp;&emsp;即使假设你正在使用有效可拆分的源流(带有一个并行化或代价低的终端操作)和非侵入（non-interfering）的函数对象，你无法从并行化中获得很好的加速效果，除非管道做了足够的实际工作来抵消使用并行化相关的成本（unless the pipeline is doing enough real work to offset the costs associated with parallelism）。作个非常粗略的估计，流中元素的数量乘以每个元素执行的代码行数应该至少为十万\[Lea14\]。

&emsp;&emsp;重要的是要记住并行化流是严格的性能优化。与任何优化一样，你必须在更改之前和之后测试性能，以确保它【的优化是】值得做【的】（第 67 项）。理想情况下，你应该在实际的系统设置中执行测试。通常，程序中的所有并行流管道都在公共 fork-join 线程池中运行。单个行为不当的管道可能会影响系统中其他不相关部分的行为。

&emsp;&emsp;听起来使用流并行会一直在违背你的意愿，它们确实是这样的(If it sounds like the odds are stacked against you when parallelizing stream pipelines, it’s because they are.)。那些维护数百万行代码的人大量使用流，只发现了在很少数的地方使用并行流是有效地。这并不意味着你应该避免并行化流。**在适当的情况下，只需通过向流管道添加并行调用，就可以实现处理器内核数量的近线性(near-linear)加速**。某些领域，例如机器学习和数据处理，特别适合这些加速。

&emsp;&emsp;作为并行性有效的流管道的一个简单示例，请考虑此函数来计算 π（n），素数小于或等于 n：

```java
// Prime-counting stream pipeline - benefits from parallelization
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
        .mapToObj(BigInteger::valueOf)
        .filter(i -> i.isProbablePrime(50))
        .count();
}
```

&emsp;&emsp;在我的机器上，使用此功能计算 π（10^8）需要 31 秒。 只需添加 parallel（）调用即可将时间缩短为 9.2 秒：

```java
// Prime-counting stream pipeline - parallel version
static long pi(long n) {
    return LongStream.rangeClosed(2, n)
        .parallel()
        .mapToObj(BigInteger::valueOf)
        .filter(i -> i.isProbablePrime(50))
        .count();
}
```

&emsp;&emsp;换句话说，并行化计算可以在我的四核机器上将其加速 3.7 倍。 值得注意的是，这并不是你在实践中如何计算大 n 值的 π（n）。有更高效的算法，特别是 Lehmer 的公式。

&emsp;&emsp;如果要并行化随机数流，请从 SplittableRandom 实例开始，而不是 ThreadLocalRandom（或基本上过时的 Random）。SplittableRandom 是专门为此而设计的，具有线性加速的潜力。ThreadLocalRandom 设计用于单个线程，并将自适应为并行流的源，但不会像 SplittableRandom 一样快。随机同步每个操作，因此会导致过度（近似杀戮）的争抢（so it will result in excessive, parallelism-killing contention）【意思应该是导致的资源争抢会很激烈】。

&emsp;&emsp;总之，除非你有充分的理由相信它将保持计算的正确性并提高其速度，否则就不应该尝试并行化流管道。不恰当地并行化流的成本可能是程序失败或性能灾难。如果你认为并行性可能是合理的，请确保在并行运行时代码保持【运行结果的】正确，并在实际条件下进行详细的性能测试。如果你的代码仍然正确并且这些实验证明你对性能提升的猜疑，那么才能在生产环境的代码中使用并行化流(If your code remains correct and these experiments bear out your suspicion of increased performance, then and only then parallelize the stream in production code.)。

## 检查参数的有效性

&emsp;&emsp;大多数方法和构造器对于传递给它们的参数值都会有某些限制。例如，索引值必须是非负数，对象引用不能为 null，这些都是很常见的。你应该在文档中清楚地指明这些所有的限制，并且在方法体的开头处检查参数，来强制执行这些限制。这是“应该在发生错误之后尽快检测出错误”这一普遍原则的一个具体情形。如果不能做到这一点，检测到错误的可能性就比较小，即使检测到错误了，也比较难以确定错误的根源。

&emsp;&emsp;如果将无效参数值传递给方法，并且该方法在执行之前检查其参数，则它很快就会失败，并且清楚地抛出合适的异常（exception）。如果这个方法没有检查它的参数，就有可能发生以下几种情形。该方法可能在处理过程中失败，并且产生令人费解的异常。更糟糕的是，该方法可以正常返回，但是会悄悄地计算出错误的结果。最糟糕的是，该方法可以正常返回，但是却使得某个对象处于被破坏的状态，将来在某个不确定的时候，在某个不相关的点上会引发错误。

&emsp;&emsp;对于公有的方法，要用 Javadoc 的@throw 标签(tag)在文档中说明违反参数值限制时会抛出的异常(第 74 项)。这样的异常通常为 IllegalArgumentException，IndexOutOfBoundsException 或 NullPointerException（第 72 项）。一旦在文档中记录了对于方法参数的限制，并且记录了一旦违反这些限制将要抛出的异常，强加这些限制就是非常简单的事情了。下面是一个典型的例子：

```java
/**
* Returns a BigInteger whose value is (this mod m). This method
* differs from the remainder method in that it always returns a
* non-negative BigInteger.
*
* @param m the modulus, which must be positive
* @return this mod m
* @throws ArithmeticException if m is less than or equal to 0
*/
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0)
        throw new ArithmeticException("Modulus <= 0: " + m);
    ... // Do the computation
}
```

&emsp;&emsp;请注意，如果 m 为 null，则文档注释不会说“mod throws NullPointerException if m is null,”，即使该方法确实会发生这种情况，这也可以作为调用 m.signum()的副产品。在封闭类 BigInteger 的类级 doc 注释中已经记录了这个异常。类级注释适用于所有类的公共方法中的所有参数。这是避免在每个方法上单独记录每个 NullPointerException【从而导致代码】混乱的好方法。它可以与@Nullable 或类似注释的使用相结合来表示特定参数可以为 null，但是这种做法不是标准的，并且会因此而使用了多个注释。

&emsp;&emsp;**在 Java 7 中添加的 Objects.requireNonNull 方法非常灵活方便，因此没有理由再手动执行空值检查**。如果你愿意，可以自定义异常的详细消息。该方法返回其输入，因此你可以在使用值的同时执行空检查：

```java
// Inline use of Java's null-checking facility
this.strategy = Objects.requireNonNull(strategy, "strategy");
```

&emsp;&emsp;你也可以忽略返回值，并使用 Objects.requireNonNull 作为满足你需求的独立空值检查。

&emsp;&emsp;在 Java 9 中，范围检查工具被添加到 java.util.Objects 中。该工具由三个方法组成：checkFromIndexSize，checkFromToIndex 和 checkIndex。此工具不如空检查方法灵活。它不允许你自定义异常的详细消息，它仅用于列表和数组索引。它不处理闭合范围（包含两个端点）。但如果它能满足你的需求，那将是一种非常有用、便利的东西。

&emsp;&emsp;对于未被导出的方法（unexported method），作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以，也应该确保只有将有效的参数值传递进来。因此，非公有的方法通常应该使用*断言（assertion）*来检查它们的参数，具体做法如下所示：

```java
// Private helper function for a recursive sort
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    ... // Do the computation
}
```

&emsp;&emsp;本质上，这些断言要求断言条件将成立，无论其客户端如何使用封闭包。不同于一般的有效性检查，断言如果失败，将会抛出 AssertionError。也不同于一般的有效性检查，如果没有启用它们，本质上也不会有成本开销，除非用过将-ea（或-enableassertions）标记（flag）传递给 Java 解释器，来启用他们。关于断言的更多信息，请参阅教程\[Asserts\]。

&emsp;&emsp;对于有些参数，方法本身没有用到，却被保存起来供以后使用，检验这类参数的有效性尤为重要。例如，考虑【原书】第 101 页中的静态工厂方法，它的参数为一个 int 数组，并返回该数组的 List 视图。如果这个方法的客户端要传递 null，该方法将会抛出一个 NullPointerException，因为该方法包含一个显式的条件检查（调用了 Objects.requireNonNull）。如果省略了这个条件检查，它就会返回一个指向新建 List 实例的引用，一旦客户端企图使用这个引用，立即会抛出 NullPointerException。到那时，要想找到 List 实例的来源可能就非常困难了，从而使得调试工作极大地复杂化了。

&emsp;&emsp;构造函数代表了一个特殊情况，即你应该检查要存储的参数的有效性以供以后使用。检查构造函数参数的有效性是非常重要的，这样可以避免构造出来的对象违反了这个类的约束条件。

&emsp;&emsp;在方法执行它的计算任务之前，应该先检查它的参数，这一规则也有例外，一个很重要的例外是，在有些情况下，有效性检查工作代价非常昂贵，或者根本是不切实际的，而且有效性检查已隐含在计算过程中完成。例如，考虑一个为对象列表排序的方法：Collections.sort(List)。列表中的所有对象都必须是可以相互比较的。在为列表排序的过程中，列表中的每个对象将与其他某个对象进行比较。如果这些对象不能相互比较，其中的某个比较操作就会抛出 ClassCastException，这正是 sort 方法应该做的事情。因此，提前检查列表中的元素是否可以相互比较，这并没有多大意义。然而，请注意，不加选择地使用这种方法将会导致失去*失败原子性（failure atomicity）*（第 76 项）。

&emsp;&emsp;有时候，某些计算会隐式地执行必要的有效性检查，但是如果检查不成功，就会抛出错误的异常。换句话说，由于无效的参数值而导致计算过程抛出的异常，与文档中表明这个方法将抛出的异常并不相符。在这种情况下，应该使用第 73 项中讲述的*异常转译（exception translation）*技术，将计算过程中抛出的异常转换为正常的异常。

&emsp;&emsp;不要从本项的内容中得出这样的结论：对参数的任何限制都是件好事。相反，在设计方法时，应该使它们尽可能地通用，并符合实际的需要。假如方法对于它能接受的所有参数值都能够完成合理的工作，对参数的限制就应该是越少越好。然而，通常情况下，有些限制对于被实现的抽象来说是内在要素（Often, however, some restrictions are intrinsic to the abstraction being implemented）。

&emsp;&emsp;简而言之，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制。应该把这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来校验这些限制。养成这样的习惯是非常重要的。只要有效性检查有一次失败，你为必要的有效性检查所付出的努力便都可以连本带利地得到偿还了。

## leetcode
### 环形链表的入口结点
```
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if(pHead == null || pHead.next == null){
            return null;
        }
            //两个指针从节点头向前运动，slow指针一次走一格，fast指针一次走两格，直到相遇
            //头结点到入口点距离a，入口点到相遇点距离为b，另一边相遇点到入口点距离为c
            //由a+(n+1)b+nc = 2(a+b)得a = c+(n-1)(b+c)
            //即一个slow指针从相遇点转圈（走了n-1圈+c），另一个从头结点出发(走了a)，最终在入口点会相遇
            ListNode fast = pHead;
            ListNode slow = pHead;
            //判断是否为环
            while(fast != null && fast.next != null){
                fast = fast.next.next;//快指针一次2步
                slow = slow.next;//慢指针一次一步
                //若相遇
                if(fast == slow){
                    ListNode slow2 = pHead;
                    while(slow != slow2){
                        slow = slow.next;
                        slow2 = slow2.next;
                    }
                    return slow2;
                }
            }
            return null;
    }
}
```

### 二叉搜索树的第k个结点
```
import java.util.ArrayList;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    //对此树中序遍历，二叉搜索树是单调递增的
    ArrayList<TreeNode> list = new ArrayList<>();
    TreeNode KthNode(TreeNode pRoot, int k) {
        if(pRoot == null || k <= 0){
            return null;
        }
        inOrder(pRoot);
        //要找的第K个结点
        if(k <= list.size()){
            return list.get(k-1);
        }else{
            return null;
        }
    }
    //递归对此树中序遍历(前序，中序，后序：pre/in/post order)
    public void inOrder(TreeNode root){
        if(root != null){
            inOrder(root.left);
            list.add(root);//前序此在1，中序此在2，后序此在3
            inOrder(root.right);
        }
    }
}
```
