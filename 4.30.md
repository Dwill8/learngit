# 4.30学习日志
## 操作系统知识
### 进程的调度算法
* **先到先服务(FCFS)**调度算法 : 从就绪队列中选择一个**最先进入**该**队列**的进程为之分配资源，使它立即执行并一直执行到**完成**或**发生某事件**而被**阻塞**放弃占用 CPU 时再重新调度。
* **短作业优先(SJF**)的调度算法 : 从就绪队列中选出一个估计**运行时间最短**的进程为之分配资源，使它立即执行并一直执行到**完成**或**发生某事件**而被阻塞放弃占用 CPU 时再重新调度。
* **时间片轮转**调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 **RR(Round robin)**调度。每个进程被**分配**一个时间段，称作它的**时间片**，即该进程允许运行的时间。
* **多级反馈队列**调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程**优先的调度算法，仅照顾了短进程而**忽略了长进程**。多级反馈队列调度算法既能使**高优先级**的作业得到响应又能使**短作业（进程）**迅速完成。，因而它是目前被公认的一种较好的进程调度算法，**UNIX**操作系统采取的便是这种调度算法。
* **优先级**调度 ： 为每个流程分配**优先级**，首先执行具有最高优先级的进程，依此类推。具有**相同**优先级的进程以 **FCFS** 方式执行。可以根据**内存**要求，**时间**要求或任何**其他资源**要求来确定优先级。

### 线程间的同步方式
* **互斥量(Mutex)**：采用**互斥对象**机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源**不会被多个线程同时访问**。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
* **信号量(Semphares)**：它允许**同一时刻多个线程**访问**同一资源**，但是需要控制同一时刻访问此资源的**最大线程数量**
* **事件(Event)**：Wait/Notify：通过**通知操作**的方式来保持多线程同步，还可以方便的实现多线程**优先级的比较**。

### linux内存
* **栈区**（stack）— 由**编译器**自动分配释放 ，存放函数的**参数值**，**局部变量**的值等。其操作方式类似于数据结构中的栈。
* **堆区**（heap） — 一般由**程序员**分配释放， 若程序员不释放，程序结束时可能由**OS回收** 。注意它与数据结构中的堆是两回事，分配方式倒是类似于**链表**。
* **全局区**（静态区）（static）—**全局变量**和**静态变量**的存储是放在一块的。**初始化**的全局变量和静态变量在一块区域， **未初始化**的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由**系统释放**。
* **文字常量区** —常量**字符串**就是放在这里的。 程序结束后由**系统释放**
* **程序代码区**—存放**函数体**的二进制代码。

### 操作系统的内存管理
操作系统的内存管理主要负责内存的**分配**与**回收**（**malloc 函数**：申请内存，**free 函数**：释放内存），另外地址转换也就是将**逻辑地址**转换成相应的**物理地址**等功能也是操作系统内存管理做的事情

* **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为**几个固定大小的块**，每个块中只包含**一个进程**。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被**浪费**了。这些在每个块中未被利用的空间，我们称之为**碎片**。
* **页式管理** ：把主存分为大小相等且固定的一页一页的形式，**页较小**，相对相比于块式管理的划分力度更大，提高了内存利用率，**减少了碎片**。页式管理通过**页表**对应**逻辑地址**和**物理地址**。
* **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的**空间小很多** 。但是，最重要的是段是有**实际意义**的，每个段定义了一组**逻辑信息**，例如,有主程序段 **MAIN**、子程序段 **X**、数据段 **D** 及栈段 **S** 等。 段式管理通过段表对应**逻辑地址**和**物理地址**。
* **段页式管理**机制 ：段页式管理机制结合了**段式管理**和**页式管理**的优点。简单来说段页式管理机制就是把主存先分成**若干段**，每个段又分成**若干页**，也就是说段页式管理机制中，段与段之间以及段的内部的都是**离散**的。

### 虚拟内存 & 虚拟内存器
虚拟内存是计算机系统**内存管理**的一种技术，我们可以**手动设置**自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个**连续的虚拟地址空间**，并且把**内存扩展到硬盘空间**。

基于局部性原理，在程序装入时，可以将程序的**一部分**装入**内存**，而将其他部分留在**外存**，就可以启动程序执行。由于外存往往比内存大很多，所以我们**运行**的软件的内存大小实际上是可以比计算机系统**实际的内存**大小要**大**的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分**调入内存**，然后继续执行程序。另一方面，操作系统将内存中**暂时不使用**的内容换到**外存**上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储器。虚拟内存同样是一种**时间换空间**的策略，用 **CPU 的计算时间**，**页的调入调出**花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。

### 虚拟内存技术的实现
**请求分页**存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了**请求调页**功能和**页面置换**功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入**当前**要执行的**部分段**即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面**调入到主存**，同时操作系统也可以将**暂时不用**的页面置换到**外存**中。

**请求分段**存储管理：建立在分段存储管理之上，增加了**请求调段**功能、**分段置换**功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入**当前**要执行的部分段即可运行；在执行过程中，可使用请求调入**中断动态**装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据**置换**功能适当调出某个段，以便腾出空间而装入新的段。

**请求段页式**存储管理

### 页面置换算法
虚拟内存管理很重要的一个概念就是**页面置换**算法。

* **地址映射**过程中，若在页面中发现所要访问的页面不在内存中，则发生**缺页中断** 。(缺页中断 就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个**分页交换文件**。)
* 当发生**缺页中断**时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其**移出内存**，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是**淘汰页面的规则**。

* **OPT** 页面置换算法（**最佳**页面置换算法）：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是**以后永不使用**的，或者是在**最长时间内**不再被访问的页面,这样可以保证获得**最低的缺页率**。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法**无法实现**。一般作为**衡量**其他置换算法的**方法**。
* **FIFO（First In First Out）** 页面置换算法（**先进先出**页面置换算法）: 总是**淘汰最先进入**内存的页面，即选择在内存中**驻留时间最久**的页面进行淘汰。
* **LRU （Least Currently Used）**页面置换算法（最近**最久未使用**页面置换算法） ：LRU算法赋予每个页面一个**访问字段**，用来记录一个页面自上次被访问以来所经历的**时间 **T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。
*** LFU （Least Frequently Used）**页面置换算法（**最少使用**页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。

## 设计模式之状态模式
允许对象在**内部状态改变**时改变它的**行为**，对象看起来好像修改了它的类。

**要点：**

- 状态模式允许一个对象基于**内部状态**而拥有不同的**行为**。
- 和**程序状态机**（PSM）不用，状态模式用**类**代表状态。
- **Context** 会将**行为**委托给当前**状态对象**。
- 通过将每个**状态**封装进一个**类**，我们把以后需要做的任何改变**局部化**了。
- **状态模式**和**策略模式**有相同的类图，但是它们的**意图**不同。
- 策略模式通常会用**行为或算法**来配置 Context 类。
- 状态模式允许 Context 随着**状态**的改变而**改变行为**。
- 状态转换可以由 **State** 类或 **Context** 类控制。
- 使用状态模式通常会导致设计中**类的数目**大量增加。
- 状态类可以被**多个** Context 实例共享。

```
//创建一个接口
public interface State {
   public void doAction(Context context);
}
```
```
public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Start State";
   }
}
```
```
public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Stop State";
   }
}
```
```
//Context 是一个带有某个状态的类
public class Context {
   private State state;
 
   public Context(){
      state = null;
   }
 
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}
```
```
//使用 Context 来查看当状态 State 改变时的行为变化
public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}
```
## 设计模式之模板方法模式
在一个方法中定义一个算法的**骨架**，而将一些步骤延迟到子类中。模板方法使得**子类**可以在不改变算法**结构**的情况下，重新定义算法中的某些步骤。

**要点：**

- “模板方法”定义了**算法的步骤**，把这些步骤的实现**延迟到子类**。
- 模板方法模式为我们提供了一种**代码复用**的重要技巧。
- 模板方法的**抽象类**可以定义**具体方法**、**抽象方法**和**钩子方法**。
- 抽象方法由**子类实现**。
- **钩子**是一种方法，它在抽象类中不做事，或者只做默认的事情，**子类**可以**选择**要不要去覆盖它。
- 为了防止子类改变模板方法中的算法，可以将模板方法声明为 **final**。
- 好莱坞原则告诉我们，将**决策权**放到**高层模块**中，以便决定如何以及何时**调用底层**模块。
- 你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的。
- **策略模式**和**模板方法模式**都封装算法，一个用**组合**，一个用**继承**。
- **工厂方法**是模板方法的一个特殊版本。

```
//创建一个抽象类，它的模板方法被设置为 final
public abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();
 
   //模板
   public final void play(){
 
      //初始化游戏
      initialize();
 
      //开始游戏
      startPlay();
 
      //结束游戏
      endPlay();
   }
}
```
```
//创建扩展了上述类的实体类
public class Cricket extends Game {
 
   @Override
   void endPlay() {
      System.out.println("Cricket Game Finished!");
   }
 
   @Override
   void initialize() {
      System.out.println("Cricket Game Initialized! Start playing.");
   }
 
   @Override
   void startPlay() {
      System.out.println("Cricket Game Started. Enjoy the game!");
   }
}
```
```
public class Football extends Game {
 
   @Override
   void endPlay() {
      System.out.println("Football Game Finished!");
   }
 
   @Override
   void initialize() {
      System.out.println("Football Game Initialized! Start playing.");
   }
 
   @Override
   void startPlay() {
      System.out.println("Football Game Started. Enjoy the game!");
   }
}
```
```
//使用 Game 的模板方法 play() 来演示游戏的定义方式
public class TemplatePatternDemo {
   public static void main(String[] args) {
 
      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();      
   }
}
```
